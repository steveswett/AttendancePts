REM /**
REM  * LoadProgramInfo.bbj
REM  * @author stevett
REM  *
REM  * Written October 2015
REM  * 
REM  * Load metadata from our source codebase into the ProgramInfoXxxx tables.
REM  *
REM  * Revised 5/17/16: Changed database tables to be case sensitive to accommodate program names
REM  *                  like "DONE" and "done".  Unfortunately, we re-use same name in lower case
REM  *                  for some BBj programs.
REM  *  
REM  * Pro/5:
REM  *
REM  *      NOTE: The following command can NOT be run, so you must use the "ListPrograms.bbj"
REM  *            program instead.
REM  * 
REM  *      /usr/local/basis/pro5/pro5lst -d/home/stevett/bbxListedPrograms -w500 -cont ./*
REM  * 
REM  *      Recommend running on nmcdev.
REM  * 
REM  * BBj: 
REM  * 
REM  *  Once BBj programs were identified, listed them on nmcDev using the following commands:
REM  *
REM  *      NOTE: MUST BE IN THE /usr/notpgm DIRECTORY WHEN RUNNING COMMANDS
REM  * 
REM  *      To catch the non *.bbj programs (need to manually prepare "bbjlist.txt" first)
REM  *  
REM  *          /usr/local/bbj/bin/bbjlst -@/home/stevett/bbjlist.txt -d/home/stevett/bbjListedPrograms
REM  * 
REM  *      To catch the *.bbj programs:
REM  * 
REM  *          /usr/local/bbj/bin/bbjlst -d/home/stevett/bbjListedPrograms ./*.bbj
REM  *  
REM  */

use java.io.File
use org.apache.commons.collections.iterators.ArrayIterator
use java.util.HashSet

declare java.io.File directory!
declare java.io.File file!
declare org.apache.commons.collections.iterators.ArrayIterator arrayIterator!
declare java.util.HashSet filesAccessedHashSet!
declare java.util.HashSet programsCalledHashSet!
declare java.util.HashSet programsRunHashSet!


begin


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:

def fnGetDateWrittenOrRevised$(aSearchPhrase$, aStmt$, aUpperCaseStmt$)

    rem  print aStmt$

    result$ = ""
    foundPosition = pos(aSearchPhrase$ = aUpperCaseStmt$)
    
    if foundPosition > 0 and len(stmt$) > foundPosition + len(aSearchPhrase$) + 1 then
        remark$ = stmt$(foundPosition + len(aSearchPhrase$) + 1)
        
        REM  Find last slash position:b
        lastSlashPos = pos("/" = remark$, -1)
        
        if lastSlashPos > 0 and len(remark$) >= lastSlashPos + 2 then 
            
            if lastSlashPos >= 6 and remark$(lastSlashPos - 3, 1) = "/" then
                result$ = remark$(lastSlashPos - 5, 8)
            else
                if lastSlashPos >= 3 then
                    result$ = remark$(lastSlashPos - 2, 5)
                endif
            endif
            
        endif
        
    endif
    
    return result$

fnend


rem *- - - - - - - - - - MAIN ROUTINE - - - - - - - - - -*

main_routine:

    gosub setup_constants
    
    gosub init
    
    gosub read_source_programs


rem *- - - - - - - - - - EOJ - - - - - - - - - -*

eoj:

    REM  release
    end


rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*


    rem ------------------------------------------------------------------------------------------
    rem  One-time intialization
    rem ------------------------------------------------------------------------------------------

    
init:

    call "ConfigVarsDAO.bbj::get_value", "is.windows.environment", configVarFound, configVarDataType$, isWindowsEnv$
    isWindowsEnv = num(isWindowsEnv$)
    
    call "ConfigVarsDAO.bbj::get_value", "notions.data.warehouse.data.source.name", configVarFound, configVarDataType$, programInfoDataSource$

    if isWindowsEnv then
        SOURCE_PROGRAM_PATH$ = "/bbjbbxListedPrograms"
    else
        SOURCE_PROGRAM_PATH$ = "/home/stevett/bbjbbxListedPrograms"
    endif


    REM  Delete all program info (will reload)
    
    print "Deleting program metadata from database ... please wait"
    
    deleteChannel = sqlunt
    sqlopen(deleteChannel) programInfoDataSource$
    
    sqlprep(deleteChannel) DELETE_PROGRAMS_QUERY$
    sqlexec(deleteChannel)
    
    sqlprep(deleteChannel) DELETE_PROGRAM_FILES_QUERY$
    sqlexec(deleteChannel)
    
    sqlprep(deleteChannel) DELETE_PROGRAM_CALLED_PROGRAMS_QUERY$
    sqlexec(deleteChannel)
    
    sqlprep(deleteChannel) DELETE_PROGRAM_RUN_PROGRAMS_QUERY$
    sqlexec(deleteChannel)
    
    sqlprep(deleteChannel) DELETE_PROGRAM_REJECTS_QUERY$
    sqlexec(deleteChannel)

    sqlclose(deleteChannel)
    
    return


    rem ------------------------------------------------------------------------------------------
    rem  Read through source programs in SOURCE_PROGRAM_PATH$
    rem ------------------------------------------------------------------------------------------
    
    
read_source_programs:

    directory! = new java.io.File(SOURCE_PROGRAM_PATH$)
    
    arrayIterator! = new org.apache.commons.collections.iterators.ArrayIterator(directory!.listFiles())
    
    programExistsChannel = sqlunt
    sqlopen(programExistsChannel) programInfoDataSource$
    sqlprep(programExistsChannel) DOES_PROGRAM_EXIST_QUERY$
    
    programsInsertChannel = sqlunt
    sqlopen(programsInsertChannel) programInfoDataSource$
    sqlprep(programsInsertChannel) INSERT_PROGRAMS_QUERY$
    
    programFilesChannel = sqlunt
    sqlopen(programFilesChannel) programInfoDataSource$
    sqlprep(programFilesChannel) INSERT_PROGRAM_FILES_QUERY$
    
    programsCalledChannel = sqlunt
    sqlopen(programsCalledChannel) programInfoDataSource$
    sqlprep(programsCalledChannel) INSERT_PROGRAM_CALLED_PROGRAMS_QUERY$
    
    programsRunChannel = sqlunt
    sqlopen(programsRunChannel) programInfoDataSource$
    sqlprep(programsRunChannel) INSERT_PROGRAM_RUN_PROGRAMS_QUERY$
    
    programRejectsChannel = sqlunt
    sqlopen(programRejectsChannel) programInfoDataSource$
    sqlprep(programRejectsChannel) INSERT_PROGRAM_REJECTS_QUERY$
    
    while arrayIterator!.hasNext()
    
        file! = cast( java.io.File, arrayIterator!.next())
        
        if !(file!.isFile()) then continue
        
        sourceProgramName$ = file!.getName()
        
REM         if len(sourceProgramName$) > 50 then
REM             print "file name, length = ", sourceProgramName$, len(sourceProgramName$)  
REM         endif
        
        REM  If empty file, skip
        if file!.length() = 0 then
        
            firstPart$ = sourceProgramName$
            extension$ = ""

            REM  Find first dot position
            firstDotPos = pos("." = sourceProgramName$)
            
            if firstDotPos > 1 then
                firstPart$ = sourceProgramName$(1, firstDotPos - 1)
            endif

            REM  Find last dot position
            lastDotPos = pos("." = sourceProgramName$, -1)
            
            if lastDotPos > 0 and lastDotPos < len(sourceProgramName$) then
                extension$ = sourceProgramName$(lastDotPos + 1)
            endif
            
            sqlexec(programRejectsChannel) sourceProgramName$, firstPart$, extension$ 
            continue
            
        endif
        
        REM if !(sourceProgramName$ = "V5800LIST") then continue


        sqlexec(programExistsChannel) sourceProgramName$ 
        
        dim resultRow$:sqltmpl(programExistsChannel)
        hits = 0

        resultRow$ = sqlfetch(programExistsChannel,err=hit_check_bombed)
        hits = resultRow.hit_count
        hit_check_bombed:
        
        if hits > 0 then continue

        gosub process_one_source_program

    wend
    
    sqlclose(programExistsChannel)
    sqlclose(programsInsertChannel)
    sqlclose(programFilesChannel)
    sqlclose(programsCalledChannel)
    sqlclose(programsRunChannel)
    sqlclose(programRejectsChannel)
 
    return
    

    rem ------------------------------------------------------------------------------------------
    rem  Process one source program -- sourceProgramName$
    rem ------------------------------------------------------------------------------------------


process_one_source_program:

    print sourceProgramName$
    
    sourceProgramChannel = unt
    open(sourceProgramChannel) SOURCE_PROGRAM_PATH$ + "/" + sourceProgramName$
    
    relativeLineNo = 0
    dateWrittenFound = FALSE
    dateRevisedFound = FALSE
    programDescription$ = ""
    dateWritten$ = ""
    dateRevised$ = ""
    
    filesAccessedHashSet! = new java.util.HashSet()
    programsCalledHashSet! = new java.util.HashSet()
    programsRunHashSet! = new java.util.HashSet()
    
    while TRUE
    
        read(sourceProgramChannel, err=*break) rawStmt$
        REM print rawStmt$
        
        REM  Handle multi-line statements:
        
        try_split:
        
        semiColonPos = pos(";" = rawStmt$)
        
        if semiColonPos > 0 then
            stmt$ = rawStmt$(1, semiColonPos - 1)
            gosub process_one_statement
            
            if len(rawStmt$) > len(stmt$) + 2 then
                rawStmt$ = rawStmt$(len(stmt$) + 2)
                goto try_split
            endif
        else
            stmt$ = rawStmt$
            gosub process_one_statement
        endif
        
        
    
    wend
    
    programDescription$ = cvs(programDescription$,3)
    if len(programDescription$) > 250 then programDescription$ = programDescription$(1,250)
    
    sqlexec(programsInsertChannel) sourceProgramName$, programDescription$, dateWritten$, dateRevised$  
    
REM     print "files accessed list ""channel - file"""

    iter! = filesAccessedHashSet!.iterator()
    
    while iter!.hasNext()
        channelAndFile$ = iter!.next()
        colonsPos = pos("::" = channelAndFile$)
REM         print channelAndFile$(1, colonsPos - 1), " - ", channelAndFile$(colonsPos + 2)
         sqlexec(programFilesChannel) sourceProgramName$, channelAndFile$(colonsPos + 2), channelAndFile$(1, colonsPos - 1) 
    wend

    
REM  Store called programs

    iter! = programsCalledHashSet!.iterator()
    
    while iter!.hasNext()
        programCalled$ = iter!.next()
        sqlexec(programsCalledChannel) sourceProgramName$, programCalled$ 
    wend

    
REM  Store run programs

    iter! = programsRunHashSet!.iterator()
    
    while iter!.hasNext()
        programRun$ = iter!.next()
        rem print "sourceProgramName$, programRun$ = ", sourceProgramName$, ", ", programRun$
        sqlexec(programsRunChannel) sourceProgramName$, programRun$ 
    wend

    
    close(sourceProgramChannel)

    return
    

    rem ------------------------------------------------------------------------------------------
    rem  Process a single statement
    rem ------------------------------------------------------------------------------------------
    
    
process_one_statement:

    relativeLineNo = relativeLineNo + 1
    
    upperCaseStmt$ = cvs(stmt$, 4)
    
    remarkPosition = pos("REM" = upperCaseStmt$)

    REM  Determine date written:
    
    if relativeLineNo <= LINE_HDRS_END and !(dateWrittenFound) then
        dateWritten$ = fnGetDateWrittenOrRevised$("REM ORG", stmt$, upperCaseStmt$)

        if len(dateWritten$) > 0 then
            dateWrittenFound = TRUE
        endif
        
    endif
    
    REM  Determine date revised:
    
    if relativeLineNo <= LINE_HDRS_END and !(dateRevisedFound) then
        dateRevised$ = fnGetDateWrittenOrRevised$("REM REV", stmt$, upperCaseStmt$)

        if len(dateRevised$) > 0 then
            dateRevisedFound = TRUE
        endif
        
    endif

    
    REM  Determine program description:
    
    if relativeLineNo <= LINE_HDRS_END and !(dateWrittenFound) and !(dateRevisedFound) then
        
        if remarkPosition > 0 and len(stmt$) > remarkPosition + 4 then
            remark$ = stmt$(remarkPosition + 4)
            programDescription$ = programDescription$ + remark$
        endif
        
    endif
    
    
    REM  TODO: What about files opened with OPNF90, OPNFIL or OPNO90?  Or OPEN91, OPEN92 or OPEN.PUB?
    
    
    REM  Spot an open90ed file:
    open90Position = pos("""OPEN90""" = stmt$)
    
    if open90Position > 0 and (remarkPosition = 0 or remarkPosition > open90Position) then
        open90AndAfter$ = stmt$(open90Position)
        firstCommaPos = pos("," = open90AndAfter$,1,1)
        secondCommaPos = pos("," = open90AndAfter$,1,2)
        thirdCommaPos = pos("," = open90AndAfter$,1,3)
        
        if firstCommaPos > 0 and secondCommaPos > 0 and thirdCommaPos > 0 then
            channel$ = cvs(open90AndAfter$(firstCommaPos + 1, secondCommaPos - firstCommaPos - 1), 3) 
            accessedFile$ = cvs(open90AndAfter$(secondCommaPos + 1, thirdCommaPos - secondCommaPos - 1), 3)
            
            REM  Trim quotes off accessedFile$
            accessedFile$ = accessedFile$(2, len(accessedFile$) - 2)

            filesAccessedHashSet!.add(channel$ + "::" + accessedFile$)
        endif
        
    endif
    
    
    REM  Spot an opened file:
    openPosition = pos("OPEN(" = stmt$)
    if openPosition = 0 then openPosition = pos("OPEN (" = stmt$)
    
    if openPosition > 0 and (remarkPosition = 0 or remarkPosition > openPosition) then
        openAndAfter$ = stmt$(openPosition)
        leftParenPos = pos("(" = openAndAfter$)
        rightParenPos = pos(")" = openAndAfter$)
        
        if leftParenPos > 0 and rightParenPos > 0 and len(openAndAfter$) > rightParenPos then
            channel$ = cvs(openAndAfter$(leftParenPos + 1, rightParenPos - leftParenPos - 1), 3)
            
            REM  Trim off options after channel, if present
            commaPos = pos("," = channel$)
            
            if commaPos > 0 then
                channel$ = channel$(1, commaPos - 1)
            endif
             
            accessedFile$ = cvs(openAndAfter$(rightParenPos + 1), 3)
            
            REM  Trim quotes off accessedFile$
            if accessedFile$(1,1) = """" then
                accessedFile$ = accessedFile$(2, len(accessedFile$) - 2)
            endif

            filesAccessedHashSet!.add(channel$ + "::" + accessedFile$)
        endif
        
    endif
    
    
    REM  Spot a called program:
    callPosition = pos("XCALL " = stmt$)
    if callPosition = 0 then callPosition = pos("CALL " = stmt$)
    
    if callPosition > 0 and (remarkPosition = 0 or remarkPosition > callPosition) then
        callAndAfter$ = stmt$(callPosition)
        firstQuotePos = pos("""" = callAndAfter$,1,1)
        secondQuotePos = pos("""" = callAndAfter$,1,2)
        
        if firstQuotePos > 0 and secondQuotePos > 0 then
            callPhrase$ = cvs(callAndAfter$(firstQuotePos + 1, secondQuotePos - firstQuotePos - 1), 3) 
            
            REM  Trim off entry point, if present
            entryPtPos = pos("::" = callPhrase$)
            
            if entryPtPos > 0 then
                callPhrase$ = callPhrase$(1, entryPtPos - 1)
            endif

            if !(programsCalledHashSet!.contains(callPhrase$)) then
                programsCalledHashSet!.add(callPhrase$)
            endif

        endif
        
    endif
    
    
    REM  Spot a run program:
    runPosition = pos("RUN " = stmt$)
    
    if runPosition > 0 and (remarkPosition = 0 or remarkPosition > runPosition) then
        runAndAfter$ = stmt$(runPosition)
        firstQuotePos = pos("""" = runAndAfter$,1,1)
        secondQuotePos = pos("""" = runAndAfter$,1,2)
        
        if firstQuotePos > 0 and secondQuotePos > 0 then
            runPhrase$ = cvs(runAndAfter$(firstQuotePos + 1, secondQuotePos - firstQuotePos - 1), 3)

            if !(programsRunHashSet!.contains(runPhrase$)) then
                programsRunHashSet!.add(runPhrase$)
            endif

        endif
        
    endif

    return
    

    rem ------------------------------------------------------------------------------------------
    rem  Setup constants - makes last subroutine due to line continuations
    rem ------------------------------------------------------------------------------------------


setup_constants:

    TRUE = 1
    FALSE = 0
    
    LINE_HDRS_END = 15
    
    DELETE_PROGRAMS_QUERY$ = "delete from ProgramInfoGeneral"
    
    DELETE_PROGRAM_FILES_QUERY$ = "delete from ProgramInfoFiles"
    
    DELETE_PROGRAM_CALLED_PROGRAMS_QUERY$ = "delete from ProgramInfoCalledPrograms"
    
    DELETE_PROGRAM_RUN_PROGRAMS_QUERY$ = "delete from ProgramInfoRunPrograms"
    
    DELETE_PROGRAM_REJECTS_QUERY$ = "delete from ProgramInfoRejects"
    
    DOES_PROGRAM_EXIST_QUERY$ = "select count(*) as hit_count from ProgramInfoGeneral where ProgramName = ?"
    
    INSERT_PROGRAMS_QUERY$ = "insert into ProgramInfoGeneral (ProgramName, Description, DateWrittenText, DateLastRevisedText) " +
:       "values(?,?,?,?)"


REM  Note: This version doesn't check for duplicates:

REM     INSERT_PROGRAM_FILES_QUERY$ = "insert into ProgramInfoFiles (ProgramName, FilePath, FileChannel) " +
REM :       "values(?,?,?)"


REM  Note: This version checks for duplicates but isn't as efficient as possible

REM     INSERT_PROGRAM_FILES_QUERY$ = "insert ProgramInfoFiles (ProgramName, FilePath, FileChannel) " + 
REM :       "select ?,?,? " +
REM :       "except " +
REM :       "select ProgramName, FilePath, FileChannel from ProgramInfoFiles"


REM  Note: This version checks for duplicates and is efficient

    INSERT_PROGRAM_FILES_QUERY$ = "" +
:       "declare " +
:       "@pgm varchar(60) = ?, " +
:       "@path varchar(100) = ?, " +
:       "@channel varchar(30) = ? " +
:       "" +
:       "if not exists " +
:       "(select * from ProgramInfoFiles where ProgramName = @pgm and FilePath = @path and FileChannel = @channel) " +
:       "insert ProgramInfoFiles (ProgramName, FilePath, FileChannel)  values ( @pgm, @path, @channel);"

    INSERT_PROGRAM_CALLED_PROGRAMS_QUERY$ = "insert into ProgramInfoCalledPrograms (ProgramName, CalledProgramName) " +
:       "values(?,?)"

    INSERT_PROGRAM_RUN_PROGRAMS_QUERY$ = "insert into ProgramInfoRunPrograms (ProgramName, RunProgramName) " +
:       "values(?,?)"

    INSERT_PROGRAM_REJECTS_QUERY$ = "insert into ProgramInfoRejects (ProgramName, FileNameFirstPart, FileExtension) " +
:       "values(?,?,?)"

    return
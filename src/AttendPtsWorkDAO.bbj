REM /**
REM  * AttendPtsWorkDAO.bbj
REM  * @author stevett
REM  * 
REM  * Written: July 2015
REM  * 
REM  * Description: Data Access Object for table ATTEND_PTS_WORK
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap
use java.util.Vector

declare java.util.LinkedHashMap datesMapOut!
declare java.util.HashMap dateQtysMap!

declare java.util.LinkedHashMap employeesMapOut!
declare java.util.HashMap employeeDataMap!

declare java.util.LinkedHashMap attPtsRecordsMapOut!
declare java.util.HashMap attPtsWorkDataMap!

declare java.util.Vector attPtsWorkIds!

declare java.util.HashMap minimalExceptionRecordsMap!
declare java.util.HashMap minimalExceptionsDataMap!

declare java.util.LinkedHashMap duplicateExceptionRecordsMap!
declare java.util.HashMap duplicateExceptionsDataMap!

declare java.util.Vector keepRecordIds!
declare java.util.Vector allRecordIds!

declare java.util.LinkedHashMap attPtsRecordsToFlagMap!


rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:

def fnIsMassLoadingExceptions(aDoIt)
    return massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
fnend


def fnGetLoginUser$(aDoIt)
    tmpUser$ = info(3, 2)
    
    if len(tmpUser$) > 10 then tmpUser$ = tmpUser$(1,10)
    
    return tmpUser$
fnend


rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


mass_load_wfmr_data:

    REM  Business dates are in format like this: "2015-07-15"

    enter businessDateFromIn$, businessDateToIn$
    
    gosub setup_constants
    
    loginUser$ = fnGetLoginUser$(TRUE)
    
    massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
    gosub run_mass_load
    
    massLoadSrc$ = MASS_LOAD_MISSED_SHIFT_SRC$
    gosub run_mass_load
    
    exit


get_dates_with_totals:

    enter shiftIn$, deptIdIn, fromDateIn, toDateIn, datesMapOut!
    
    gosub setup_constants
    
    gosub load_dates_map
    
    exit


get_employees_for_date:

    enter shiftIn$, deptIdIn, dateIn!, employeesMapOut!
    
    gosub setup_constants
    
    gosub load_employees_map
    
    exit


get_records_by_ids_in_list:

    enter attPtsWorkIds!, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub load_work_records_map
    
    exit


get_records_where_exceptions_no_longer_exist:

    enter skipAlreadyFlaggedOnes, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub get_work_records_map_where_exceptions_no_longer_exist
    
    exit


get_records_where_missed_shifts_no_longer_exist:

    enter skipAlreadyFlaggedOnes, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub get_work_records_map_where_missed_shifts_no_longer_exist
    
    exit
    

get_count_by_exc_date_and_source_map:    

    enter fromDateIn, toDateIn, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub load_count_by_exc_date_and_source_map
    
    exit
    

get_data_for_duplicate_exceptions_map:    

    enter fromYymdIn$, toYymdIn$, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub load_data_for_duplicate_exceptions_map
    
    exit
    

flag_duplicate_exceptions_using_map:    

    enter duplicateExceptionRecordsMap!, duplicatesFlaggedCountOut
    
    gosub setup_constants
    
    gosub flag_duplicate_exceptions_in_map
    
    exit


get_date_of_most_recent_exception_loaded:

    enter yyyymmddOut$
    
    gosub setup_constants
    
    gosub get_yyyymmdd_of_most_recent_exception_loaded
    
    exit


flag_records_where_wfmr_recds_no_longer_exist:

    enter attPtsRecordsToFlagMap!
    
    gosub setup_constants
    
    gosub flag_work_records_map_where_wfmr_recds_no_longer_exist
    
    exit


save_one_record:

    enter attPtsWorkDataMap!
    
    gosub setup_constants
    
    gosub save_record_from_map
    
    exit
    
    
open_and_prep_channel_to_flag_posting:

    enter flagPostingChannelOut
    
    gosub setup_constants

    flagPostingChannelOut = sqlunt
    sqlopen(flagPostingChannelOut) attendPtsDataSource$
    sqlprep(flagPostingChannelOut) ATTEND_PTS_WORK_UPDATE_POSTED_FLAG_STMT$
    
    exit

    
flag_posting:

    enter flagPostingChannelIn, recordIdIn, userIdIn$, wfmrExceptionDefIdIn
    
    gosub setup_constants
    
    gosub update_posted_flag_on_record
    
    exit
    
    
close_channel_to_flag_posting:

    enter flagPostingChannelIn
    
    sqlclose(flagPostingChannelIn)
    
    exit
    

rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------------------------------------
REM  Mass load WFMR exception and missed shift data
REM  ------------------------------------------------------------------------------------------

run_mass_load:

    gosub ml_init
    gosub ml_open_sql_channels
    gosub ml_prepare_sql_stmts
    gosub ml_process_wfmr_data
    gosub ml_close_sql_channels

    return

REM  ------------------------------------------------------------------------------------------
REM  Mass Load Init
REM  ------------------------------------------------------------------------------------------

ml_init:

    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$
    
    if fnIsMassLoadingExceptions(TRUE) then
        wfmrSelectStmt$ = WFMR_EXCEPTIONS_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_EXCEPTIONS_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$
    else
        wfmrSelectStmt$ = WFMR_MISSED_SHIFT_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_MISSED_SHIFT_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$
    endif
    
    totalInserted = 0
    
    readCount = 0
    insertCount = 0
    batchNo = 0

    return


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Open SQL Channels
REM  ------------------------------------------------------------------------------------------

ml_open_sql_channels:

    attendPtsFindRowChannel = sqlunt
    sqlopen(attendPtsFindRowChannel) attendPtsDataSource$
    
    attendPtsInsertRowsChannel = sqlunt
    sqlopen(attendPtsInsertRowsChannel) attendPtsDataSource$
    
    attendPtsUpdateRowChannel = sqlunt
    sqlopen(attendPtsUpdateRowChannel) attendPtsDataSource$
    
    wfmrSelectRowsChannel = sqlunt
    sqlopen(wfmrSelectRowsChannel) wfmrDataSource$
    
    return; rem 1


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Prepare SQL Statements
REM  ------------------------------------------------------------------------------------------

ml_prepare_sql_stmts:

    sqlprep(attendPtsFindRowChannel) attendPtsFindStmt$
    sqlprep(attendPtsUpdateRowChannel) attendPtsUpdateStmt$
    sqlprep(wfmrSelectRowsChannel) wfmrSelectStmt$
    
    print $0A$,"AttendPtsWorkDAO.bbj - ml_prepare_sql_stmts. wfmrSelectStmt$ = "
    print wfmrSelectStmt$

    return; rem 2


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Process WFMR Data
REM  ------------------------------------------------------------------------------------------

ml_process_wfmr_data:

    sqlexec(wfmrSelectRowsChannel)
    
    dim wfmrResultRow$:sqltmpl(wfmrSelectRowsChannel)
    
    while TRUE

        REM  "while", "repeat" and "for" use same stack as gosub, so requires exitto.  "break" may work.  For BBj, *break on err= works.
    
        wfmrResultRow$ = sqlfetch(wfmrSelectRowsChannel,err=*break)
        
        readCount = readCount + 1
        
        hits = 0
        
        if fnIsMassLoadingExceptions(TRUE) then
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.exception_id
        else
            tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$ 
        endif
        
        dim ptsResultRow$:sqltmpl(attendPtsFindRowChannel)
        ptsResultRow$ = sqlfetch(attendPtsFindRowChannel,err=hit_check_bombed)
        hits = ptsResultRow.hit_count
        hit_check_bombed:
        
        if !(fnIsMassLoadingExceptions(TRUE)) then
            if wfmrResultRow.type_code$ = "n" then 
                derived_exception_id = 11
                else 
                if wfmrResultRow.type_code$ = "c" then derived_exception_id = 46
            endif
        endif
 
        
        if PRINT_TRACE_INFO and readCount < 2 then
            if fnIsMassLoadingExceptions(TRUE) then 
                print "exception_id = ", wfmrResultRow.exception_id
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "exception_date = ", wfmrResultRow.exception_date$
                print "exception_definition_id = ", wfmrResultRow.exception_definition_id
                print "exception_descr = ", wfmrResultRow.exception_descr$
                print "exception_last_mod = ", wfmrResultRow.exception_last_mod$
                print "hits = ", hits
                print $0A$
            else
                print "in_timestamp = ", wfmrResultRow.in_timestamp$
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "missed_shift_date = ", wfmrResultRow.missed_shift_date$
                print "derived_exception_id = ", derived_exception_id
                print "missed_shift_last_mod = ", wfmrResultRow.missed_shift_last_mod$
                print "hits = ", hits
                print $0A$
            endif
        endif
        
        if hits = 0 then
           gosub ml_add_to_insert_batch
        else
           gosub ml_update_row
        endif
        
    wend

    return; rem 3


REM  ------------------------------------------------------------------------------------------
REM  Load one set of info per work file date into the datesMapOut!
REM  ------------------------------------------------------------------------------------------
    
load_dates_map:
    
    datesMapOut!.clear()
    
    REM  Step 1. Query the ATTEND_PTS_WORK file: populate totals
    
    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_TOTALS_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        dateQtysMap! = new java.util.HashMap()
        dateQtysMap!.put("total", resultRow.total)
        dateQtysMap!.put("posted", 0)
        
        REM  In following, key is disposition code:
        dateQtysMap!.put("A", 0)
        dateQtysMap!.put("E", 0)
        dateQtysMap!.put("F", 0)
        dateQtysMap!.put("N", 0)

        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend

    
    REM  Step 2. Query the ATTEND_PTS_WORK file: populate posted/not posted
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_POSTED_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        if !(cvs(resultRow.posted_timestamp$, 3) = "") then
            dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
            posted = dateQtysMap!.get("posted")
            posted = posted + resultRow.posted_count
            dateQtysMap!.put("posted", posted)
            datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        endif
        
    wend

    
    REM  Step 3. Query the ATTEND_PTS_WORK file: populate disposition status
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_DISPOSITION_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
        
        tmpTotal = dateQtysMap!.get(resultRow.disp_cd$)
        tmpTotal = tmpTotal + resultRow.disp_count
        dateQtysMap!.put(resultRow.disp_cd$, tmpTotal)
        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)


    return


REM  ------------------------------------------------------------------------------------------
REM  For one date, Load a set of info per employee into the employeesMapOut!
REM  ------------------------------------------------------------------------------------------
    
load_employees_map:

    employeesMapOut!.clear()

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, dateIn!, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        employeeDataMap! = new java.util.HashMap()
        employeeDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        employeeDataMap!.put("disp_cd", resultRow.disp_cd$)
        employeeDataMap!.put("sched_shift_id", resultRow.sched_shift_id)
        employeeDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        employeeDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        employeeDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        employeeDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        employeeDataMap!.put("erp_cd", resultRow.erp_cd$)
        employeeDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        employeeDataMap!.put("erp_note", resultRow.erp_note$)

        employeesMapOut!.put(resultRow.id, employeeDataMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Get a count of records grouped by WFMR exception date and WFMR source (E or M).  For 
REM  each group-by record, add a HashMap of data into the attPtsRecordsMapOut! LinkedHashMap
REM  ------------------------------------------------------------------------------------------
    
load_count_by_exc_date_and_source_map:

    attPtsRecordsMapOut!.clear()

    tempChannel = sqlunt
    sqlopen(tempChannel) attendPtsDataSource$
    
    sqlprep(tempChannel) GET_COUNT_BY_DATE_AND_SRC_STMT$

    sqlexec(tempChannel) fromDateIn, toDateIn 
    dim resultRow$:sqltmpl(tempChannel)
    
    tempCount = 0
    
    while TRUE
    
        resultRow$ = sqlfetch(tempChannel,err=*break)
        attPtsWorkDataMap! = new java.util.HashMap()

        attPtsWorkDataMap!.put("wfmr_exc_date", resultRow.wfmr_exc_date$)
        attPtsWorkDataMap!.put("wfmr_src", resultRow.wfmr_src$)
        attPtsWorkDataMap!.put("qty", resultRow.qty)

        tempCount = tempCount + 1
        attPtsRecordsMapOut!.put(tempCount, attPtsWorkDataMap!)
        
    wend
    
    sqlclose(tempChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Get a count and data for duplicate exception records.  Records are grouped by 
REM  WFMR exception date, employee, scheduled shift and excedption definition ID.  For 
REM  each group-by record, add a HashMap of data into the attPtsRecordsMapOut! LinkedHashMap
REM  ------------------------------------------------------------------------------------------
    
load_data_for_duplicate_exceptions_map:

    attPtsRecordsMapOut!.clear()

    tempChannel = sqlunt
    sqlopen(tempChannel) attendPtsDataSource$
    
    sqlprep(tempChannel) GET_COUNT_AND_DATA_FOR_DUP_EXCEPTIONS_STMT$

    sqlexec(tempChannel) fromYymdIn$, toYymdIn$ 
    dim resultRow$:sqltmpl(tempChannel)
    
    tempCount = 0
    
    while TRUE
    
        resultRow$ = sqlfetch(tempChannel,err=*break)
        attPtsWorkDataMap! = new java.util.HashMap()

        attPtsWorkDataMap!.put("wfmr_exc_date", resultRow.wfmr_exc_date$)
        attPtsWorkDataMap!.put("emp_badge_no", resultRow.emp_badge_no$)
        attPtsWorkDataMap!.put("sched_shift_id", resultRow.sched_shift_id)
        attPtsWorkDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        attPtsWorkDataMap!.put("dup_count", resultRow.dup_count)

        tempCount = tempCount + 1
        attPtsRecordsMapOut!.put(tempCount, attPtsWorkDataMap!)
        
    wend
    
    sqlclose(tempChannel)

    return
    

REM  ------------------------------------------------------------------------------------------
REM  For employees/dates identified in duplicate exceptions map, duplicateExceptionsDataMap!,
REM  flag unposted, not handled ones as being duplicates to ignore.  This was needed because
REM  on 11/2/15, ops supervisors noticed a bunch of duplicate records (305) -- especially
REM  between 10/18 and 10/24/15 -- caused by WFMR deleting original exceptions and then
REM  re-adding new ones with different keys. 
REM  ------------------------------------------------------------------------------------------


flag_duplicate_exceptions_in_map:

    duplicatesFlaggedCountOut = 0

    readMapChannel = sqlunt
    sqlopen(readMapChannel) attendPtsDataSource$
    sqlprep(readMapChannel) GET_ROWS_PER_DATE_AND_EMPLOYEE_WITH_DUP_EXCEPTIONS_STMT$

    flagChannel = sqlunt
    sqlopen(flagChannel) attendPtsDataSource$
    sqlprep(flagChannel) FLAG_AS_WFMR_EXCEPTION_DUPLICATE_STMT$

    iter! = duplicateExceptionRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
        idKey! = iter!.next()
        duplicateExceptionsDataMap! = cast( java.util.HashMap, duplicateExceptionRecordsMap!.get(idKey!) )
        
        wfmrExcDate$ = duplicateExceptionsDataMap!.get("wfmr_exc_date")
        badgeNo$ = duplicateExceptionsDataMap!.get("emp_badge_no")
        schedShiftId = duplicateExceptionsDataMap!.get("sched_shift_id")
        wfmrExcDefId = duplicateExceptionsDataMap!.get("wfmr_exc_def_id")
        
        sqlexec(readMapChannel) wfmrExcDate$, badgeNo$, schedShiftId, wfmrExcDefId  
        dim resultRow$:sqltmpl(readMapChannel)

        
        REM  Step 1. Determine which records to keep
        REM  Note: Records will be read in (1) most recent posted order; then (2) most recent last mod order
        
        keepRecordIds! = new java.util.Vector()
        allRecordIds! = new java.util.Vector()

        REM  Keep the following:
        REM     1. posted ones 
        REM     2. those other than "Not Handled" (disposition code "N")
        REM     3. the first "Not Handled" (but only if ALL are "Not Handled")
        
        notHandledCount = 0
        otherCount = 0
        firstNotHandledId = 0
                 
        while TRUE
        
            resultRow$ = sqlfetch(readMapChannel,err=*break)
            allRecordIds!.add(resultRow.id)
            
            wasPosted = len( cvs(resultRow.posted_timestamp$, 3) ) > 0
            
            if wasPosted or !(resultRow.disp_cd$ = "N") then
                keepRecordIds!.add(resultRow.id)
            endif
            
            if resultRow.disp_cd$ = "N" then
                notHandledCount = notHandledCount + 1
                
                if firstNotHandledId = 0 then
                    firstNotHandledId = resultRow.id
                endif
            else
                otherCount = otherCount + 1
            endif
            
        wend
        
        REM  This is the keeper for "3. the first "Not Handled" (but only if ALL are "Not Handled")"
        
        if otherCount = 0 and firstNotHandledId > 0 and !( keepRecordIds!.contains(firstNotHandledId) ) then
            keepRecordIds!.add(firstNotHandledId)
        endif
        
        
        REM  Step 2. Flag non-keepers as duplicates
        
        if allRecordIds!.size() > keepRecordIds!.size() then

            call "DateUtilities.bbj::get_current_timestamp", currentTimestamp$
            
            REM  Remove keepers from allRecordIds!
            
            allRecordIds!.removeAll(keepRecordIds!)
            
            idCount = allRecordIds!.size()
    
            for i = 0 to idCount - 1
                idToRemove = allRecordIds!.get(i)
                sqlexec(flagChannel) currentTimestamp$, idToRemove
                duplicatesFlaggedCountOut = duplicatesFlaggedCountOut + 1  
            next i

        endif

    wend
    
    sqlclose(flagChannel)
    sqlclose(readMapChannel)

    return
    

REM  ------------------------------------------------------------------------------------------
REM  Get date of most recent exception loaded
REM  ------------------------------------------------------------------------------------------
    
get_yyyymmdd_of_most_recent_exception_loaded:

    rem Just some random default:
    yyyymmddOut$ = "19500101"
    
    tempChannel = sqlunt
    sqlopen(tempChannel) attendPtsDataSource$

    sqlprep(tempChannel) GET_MOST_RECENT_EXCEPTION_DATE_LOADED_STMT$

    sqlexec(tempChannel) 
    dim resultRow$:sqltmpl(tempChannel)
    
    resultRow$ = sqlfetch(tempChannel,err=skip_ymd_out)
    yyyymmddOut$ = resultRow.wfmr_exc_date$
    
    skip_ymd_out:
    
    sqlclose(tempChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Load a set of info into the attPtsRecordsMapOut! -- but only for
REM  records that no longer exist in the WFMR Lab_Exceptions table.
REM  ------------------------------------------------------------------------------------------


get_work_records_map_where_exceptions_no_longer_exist:

    REM  Step 1. Get all punch exceptions in the ATTEND_PTS_WORK table
    
    minimalExceptionsChannel = sqlunt
    sqlopen(minimalExceptionsChannel) attendPtsDataSource$
    
    if skipAlreadyFlaggedOnes then
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_SKIP_FLAGGED_STMT$
    else
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_STMT$
    endif

    sqlexec(minimalExceptionsChannel) 
    dim resultRow$:sqltmpl(minimalExceptionsChannel)
        
    minimalExceptionRecordsMap! = new java.util.HashMap()
    
    while TRUE
    
        resultRow$ = sqlfetch(minimalExceptionsChannel,err=*break)
        minimalExceptionsDataMap! = new java.util.HashMap()
        minimalExceptionsDataMap!.put("wfmr_exception_id", resultRow.wfmr_exc_id)
        minimalExceptionRecordsMap!.put(resultRow.id, minimalExceptionsDataMap!)
        
    wend
    
    sqlclose(minimalExceptionsChannel)

    
    REM  Step 2. Check to see if any of the punch exceptions are missing in WFMR.  If so,
    REM          add ATTEND_PTS_WORK ID to attPtsWorkIds! vector. 
    
    call "WFMRExceptionDAO.bbj::append_missing_exception_info_to_map", minimalExceptionRecordsMap!
    
    attPtsWorkIds! = new java.util.Vector()
    
    iter! = minimalExceptionRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        minimalExceptionsDataMap! = cast( java.util.HashMap, minimalExceptionRecordsMap!.get(idKey!) )
        
        if minimalExceptionsDataMap!.containsKey("missing_in_wfmr") then
            attPtsWorkIds!.add(idKey!)
        endif

    wend
    
    
    REM  Step 3. For all IDs in the attPtsWorkIds! vector, load the map of attendance point records (to return)

    attPtsRecordsMapOut!.clear()

    if attPtsWorkIds!.size() > 0 then
        gosub load_work_records_map
    endif

    return


REM  ------------------------------------------------------------------------------------------
REM  Load a set of info into the attPtsRecordsMapOut! -- but only for
REM  records that no longer exist in the WFMR Lab_Employee_Missed_Shifts table.
REM  ------------------------------------------------------------------------------------------


get_work_records_map_where_missed_shifts_no_longer_exist:

    REM  Step 1. Get all missed shifts in the ATTEND_PTS_WORK table
    
    minimalExceptionsChannel = sqlunt
    sqlopen(minimalExceptionsChannel) attendPtsDataSource$
    
    if skipAlreadyFlaggedOnes then
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_MISSED_SHIFTS_SKIP_FLAGGED_STMT$
    else
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_MISSED_SHIFTS_STMT$
    endif

    sqlexec(minimalExceptionsChannel) 
    dim resultRow$:sqltmpl(minimalExceptionsChannel)
        
    minimalExceptionRecordsMap! = new java.util.HashMap()
    
    while TRUE
    
        resultRow$ = sqlfetch(minimalExceptionsChannel,err=*break)
        minimalExceptionsDataMap! = new java.util.HashMap()
        minimalExceptionsDataMap!.put("emp_id", resultRow.emp_id)
        minimalExceptionsDataMap!.put("bus_unit_id", resultRow.bus_unit_id)
        minimalExceptionsDataMap!.put("job_id", resultRow.job_id)
        minimalExceptionsDataMap!.put("wfmr_in_tm_miss", resultRow.wfmr_in_tm_miss$)
        minimalExceptionRecordsMap!.put(resultRow.id, minimalExceptionsDataMap!)
        
    wend
    
    sqlclose(minimalExceptionsChannel)

    
    REM  Step 2. Check to see if any of the missed shifts are missing in WFMR.  If so,
    REM          add ATTEND_PTS_WORK ID to attPtsWorkIds! vector. 
    
    call "WFMRMissedShiftsDAO.bbj::append_missing_missed_shift_info_to_map", minimalExceptionRecordsMap!
    
    attPtsWorkIds! = new java.util.Vector()
    
    iter! = minimalExceptionRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        minimalExceptionsDataMap! = cast( java.util.HashMap, minimalExceptionRecordsMap!.get(idKey!) )
        
        if minimalExceptionsDataMap!.containsKey("missing_in_wfmr") then
            attPtsWorkIds!.add(idKey!)
        endif

    wend
    
    
    REM  Step 3. For all IDs in the attPtsWorkIds! vector, load the map of attendance point records (to return)

    attPtsRecordsMapOut!.clear()

    if attPtsWorkIds!.size() > 0 then
        gosub load_work_records_map
    endif

    return
    

REM  ------------------------------------------------------------------------------------------
REM  Flag all records in attPtsRecordsToFlagMap! with current timestamp
REM  ------------------------------------------------------------------------------------------
    
    
flag_work_records_map_where_wfmr_recds_no_longer_exist:

    flagChannel = sqlunt
    sqlopen(flagChannel) attendPtsDataSource$
    sqlprep(flagChannel) ATTEND_PTS_WORK_FLAG_THAT_WFMR_RECORD_NO_LONGER_EXISTS_STMT$
    
    call "DateUtilities.bbj::get_current_timestamp", currentTimestamp$

    iter! = attPtsRecordsToFlagMap!.keySet().iterator()
    
    while iter!.hasNext()
        idKey! = iter!.next()
        sqlexec(flagChannel) currentTimestamp$, idKey! 
    wend
    
    sqlclose(flagChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Update posted fields: timestamp, by user, WFMR exception def id
REM  ------------------------------------------------------------------------------------------
    
update_posted_flag_on_record:

        call "DateUtilities.bbj::get_current_timestamp", currentTimestamp$
        sqlexec(flagPostingChannelIn) currentTimestamp$, userIdIn$, wfmrExceptionDefIdIn, recordIdIn

    return
    

REM  ------------------------------------------------------------------------------------------
REM  Mass Load Update a Row
REM  ------------------------------------------------------------------------------------------

ml_update_row:
    
    REM  IMPORTANT: Was getting error 77 SQL before I added "cvs" to trim trailing blanks -- due to field being too long.

    call "DateUtilities.bbj::get_current_timestamp", updateTimestamp$
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel) 
:           updateTimestamp$, loginUser$,
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), wfmrResultRow.employee_id, 
:           cvs(wfmrResultRow.badge_number$, 2), wfmrResultRow.scheduled_shift_id, wfmrResultRow.job_id,
:           wfmrResultRow.exception_date$, wfmrResultRow.exception_definition_id, str(erpPts), tempLastModDate$,
:           wfmrResultRow.exception_id, tempLastModDate$
    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) 
        tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel)
:           updateTimestamp$, loginUser$,
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), cvs(wfmrResultRow.badge_number$, 2), wfmrResultRow.scheduled_shift_id,
:           wfmrResultRow.missed_shift_date$, derived_exception_id, str(erpPts), tempLastModDate$, wfmrResultRow.reason_id,
:           wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$,
:           tempLastModDate$  
    endif

    return; rem 4
    

REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Add a values phrase to an Insert Statement
REM  ------------------------------------------------------------------------------------------

ml_add_to_insert_batch:

    insertCount = insertCount + 1
    
    if insertCount > 1 then attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + ","
    
    call "DateUtilities.bbj::get_current_timestamp", insertTimestamp$
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'E', " +
:          str(wfmrResultRow.exception_id) + ", " +
:          "0, " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.exception_date$ + "', " +
:          str(wfmrResultRow.exception_definition_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + insertTimestamp$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "', " + 
:          "0, " +
:          "0, " +
:          "'', " +
:          str(wfmrResultRow.scheduled_shift_id) + ", " +
:          "''" +
:          ")"

    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$

        REM  If a reason code has been entered on the missed shift record, tack a description onto the erpNote$
        
        reasonName$ = cvs(wfmrResultRow.reason_name$, 2)
        
        if len(reasonName$) > 0 then
            erpNote$ = cvs(erpNote$, 2) + " - " + reasonName$
        endif
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'M', " +
:          "0, " +
:          "'" + wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) + "', " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.missed_shift_date$ + "', " +
:          str(derived_exception_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + insertTimestamp$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "', " + 
:          "0, " +
:          str(wfmrResultRow.reason_id) + ", " +
:          "'', " +
:          str(wfmrResultRow.scheduled_shift_id) + ", " +
:          "''" +
:          ")"
    endif
    
    attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + valuesClause$ 

    if insertCount = BATCH_SIZE then gosub ml_write_batch

    return; rem 5


REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Write the Insert Batch
REM  ------------------------------------------------------------------------------------------

ml_write_batch:

    batchNo = batchNo + 1
    
    print "batchNo = ", batchNo

    sqlprep(attendPtsInsertRowsChannel) attendPtsDynamicInsertStmt$
    sqlexec(attendPtsInsertRowsChannel)
    
    totalInserted = totalInserted + insertCount
    
    insertCount = 0
    
    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$

    return; rem 6


REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Close SQL Channels
REM  ------------------------------------------------------------------------------------------

ml_close_sql_channels:

    sqlclose(wfmrSelectRowsChannel)
    
    if insertCount > 0 then gosub ml_write_batch
    
    sqlclose(attendPtsFindRowChannel)
    sqlclose(attendPtsInsertRowsChannel)
    sqlclose(attendPtsUpdateRowChannel)

    return; rem 7    


REM  ------------------------------------------------------------------------------------------
REM  For each id in list, load a set of info into the attPtsRecordsMapOut!
REM  ------------------------------------------------------------------------------------------

    
load_work_records_map:

    attPtsRecordsMapOut!.clear()
    
    REM  Build CSV list of ids from incoming vector:
    
    inClause$ = ""
    
    idCount = attPtsWorkIds!.size()
    
    for i = 0 to idCount - 1
    
        if i > 0 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + str( attPtsWorkIds!.get(i) ) 
         
    next i
    
    REM  Unfortunately, you can't use a single ? parm in a prepared query for a list of ids

    attendPtsWorkGetRecordsByIdListStmt$ =
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.emp_badge_no, " +
:       "attend_pts_work.wfmr_src, " +
:       "attend_pts_work.wfmr_exc_id, " +
:       "attend_pts_work.wfmr_exc_date, " +
:       "attend_pts_work.sched_shift_id, " +
:       "attend_pts_work.job_id, " +
:       "attend_pts_work.wfmr_exc_def_id, " +
:       "attend_pts_work.wfmr_reason_id, " +
:       "attend_pts_work.wfmr_pts_assess, " +
:       "attend_pts_work.wfmr_exc_lastmod, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.disp_edt_reas_id, " +
:       "attend_pts_reasn.descr as edt_reas_descr, " +
:       "attend_pts_work.erp_cd, " +
:       "attend_pts_work.erp_note, " +
:       "attend_pts_work.erp_pts_assessed, " +
:       "attend_pts_work.erp_sts_cd, " +
:       "attend_pts_work.last_mod, " +
:       "attend_pts_work.last_mod_user, " +
:       "attend_pts_work.posted_timestamp, " +
:       "attend_pts_work.posted_by_user, " +
:       "attend_pts_work.posted_exc_defid " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "left join attend_pts_reasn on attend_pts_reasn.id = attend_pts_work.disp_edt_reas_id " +
:       "where id in(" +
:       inClause$ +
:       ")"

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) attendPtsWorkGetRecordsByIdListStmt$
    

    sqlexec(attendPtsWorkDatesChannel)  
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)

    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        attPtsWorkDataMap! = new java.util.HashMap()
        
        attPtsWorkDataMap!.put("id", resultRow.id)
        attPtsWorkDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        attPtsWorkDataMap!.put("emp_badge_no", resultRow.emp_badge_no$)
        attPtsWorkDataMap!.put("wfmr_src", resultRow.wfmr_src$)
        attPtsWorkDataMap!.put("wfmr_exc_id", resultRow.wfmr_exc_id)
        attPtsWorkDataMap!.put("wfmr_exc_date", resultRow.wfmr_exc_date$)
        attPtsWorkDataMap!.put("sched_shift_id", resultRow.sched_shift_id)
        attPtsWorkDataMap!.put("job_id", resultRow.job_id)
        attPtsWorkDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        attPtsWorkDataMap!.put("wfmr_reason_id", resultRow.wfmr_reason_id)
        attPtsWorkDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        attPtsWorkDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        attPtsWorkDataMap!.put("disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("edt_reas_descr", resultRow.edt_reas_descr$)
        attPtsWorkDataMap!.put("erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("erp_sts_cd", resultRow.erp_sts_cd$)
        attPtsWorkDataMap!.put("last_mod", resultRow.last_mod$)
        attPtsWorkDataMap!.put("last_mod_user", resultRow.last_mod_user$)
        attPtsWorkDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        attPtsWorkDataMap!.put("posted_by_user", resultRow.posted_by_user$)
        attPtsWorkDataMap!.put("posted_exc_defid", resultRow.posted_exc_defid)
        
        REM  Save original values of editable ERP fields:

        attPtsWorkDataMap!.put("orig_disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("orig_disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("orig_erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("orig_erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("orig_erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("orig_erp_sts_cd", resultRow.erp_sts_cd$)
        
        attPtsRecordsMapOut!.put(resultRow.id, attPtsWorkDataMap!)
        
    wend        
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Save a single record's data stored in attPtsWorkDataMap!
REM  ------------------------------------------------------------------------------------------
    
save_record_from_map:

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$
    
    call "DateUtilities.bbj::get_current_timestamp", lastModTimeStamp$
    loginUser$ = info(3,2) 

    sqlexec(attendPtsWorkDatesChannel) attPtsWorkDataMap!.get("disp_cd"), attPtsWorkDataMap!.get("disp_edt_reas_id"),
:       attPtsWorkDataMap!.get("erp_cd"), attPtsWorkDataMap!.get("erp_note"), attPtsWorkDataMap!.get("erp_pts_assessed"),
:       attPtsWorkDataMap!.get("erp_sts_cd"), lastModTimeStamp$, loginUser$, attPtsWorkDataMap!.get("id")  

    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Define constants
REM  ------------------------------------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0
    
    ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$ = "current.attend.pts.policy.code"
    
    MASS_LOAD_EXCEPTIONS_SRC$ = "E"
    MASS_LOAD_MISSED_SHIFT_SRC$ = "M"
    
    PRINT_TRACE_INFO = FALSE
    BATCH_SIZE = 500
    
    DEFAULT_DISPOSITION_CODE$ = "N"
    DEFAULT_DISPOSITION_EDIT_REASON_ID = 0
    DEFAULT_LAST_MANUALLY_MODIFIED_USER$ = ""
    DEFAULT_POSTED_TIMESTAMP$ = ""
    DEFAULT_POSTED_USER$ = ""
    
    REM Uses the data source names in the SQL.INI file
    
    attendPtsDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$
    
    wfmrDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "wfmr.data.source.name", configVarFound, configVarDataType$, wfmrDataSource$
    
    attendPtsPolicyCode$ = ""
    call "ConfigVarsDAO.bbj::get_value", ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$, configVarFound, configVarDataType$, attendPtsPolicyCode$

    call "AttendPtsTransDAO.bbj::get_exception_ids_as_csv", attendPtsPolicyCode$, exceptionIdsAsCSV$

    call "ConfigVarsDAO.bbj::get_value", "use.custom.column.table.for.shift", configVarFound, configVarDataType$, useCustomColumnTableForShift$
    useCustomColumnTableForShift = num(useCustomColumnTableForShift$)

    if useCustomColumnTableForShift then
        call "ConfigVarsDAO.bbj::get_value", "custom.column.def.id.for.shift", configVarFound, configVarDataType$, customColumnDefIdForShift$
    endif

    
    REM  Break up field list into 5 fields per row (so readable)
       
    STARTING_INSERT_STMT$ =
:        "insert into ATTEND_PTS_WORK " +
:        "(id, wfmr_src, wfmr_exc_id, wfmr_in_tm_miss, bus_unit_id, " +
:        "dept_id, shift, emp_id, emp_badge_no, job_id, " +
:        "wfmr_exc_date, wfmr_exc_def_id, wfmr_pts_assess, wfmr_exc_lastmod, disp_cd, " +
:        "disp_edt_reas_id, erp_cd, erp_note, erp_pts_assessed, erp_sts_cd, " +
:        "last_mod, last_mod_user, posted_timestamp, posted_by_user, posted_exc_defid, " +
:        "wfmr_reason_id, exc_gone_stamp, sched_shift_id, exc_dup_stamp) " +
:        "values "


    REM  Probably could have parameterized the following query with ?

    WFMR_EXCEPTIONS_SELECT_STMT$ = 
:       "select " +
:        "Lab_Exception.exception_id, " +
:        "Lab_Exception.business_unit_id, " +
:        "Lab_Job.department_id, "

    if useCustomColumnTableForShift then
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "Lab_Employee_Custom_Column.column_value as shift, "
    else
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "Lab_Employee_Attribute.attribute_code as shift, "
    endif

    WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:        "Lab_Exception.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Exception.scheduled_shift_id, " +
:        "Lab_Exception.job_id, " +
:        "convert(varchar(8), Lab_Exception.business_date, 112) as exception_date, " +
:        "Lab_Exception.exception_definition_id, " +
:        "Lab_Exception_Definition.name as exception_descr, " +
:        "convert(varchar(19), Lab_Exception.last_modified_timestamp, 120) as exception_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name " +
:        "from Lab_Exception " + 
:        "inner join Lab_Exception_Definition on Lab_Exception.exception_definition_id = Lab_Exception_Definition.exception_definition_id " + 
:        "inner join Rad_Sys_User on Lab_Exception.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Exception.employee_id = Employee.employee_id " + 
:        "inner join Lab_Punch_Shift on Lab_Exception.shift_start_punch_id = Lab_Punch_Shift.shift_start_punch_id " +
:        "inner join Lab_Job on Lab_Exception.job_id = Lab_Job.job_id "

    if useCustomColumnTableForShift then
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "inner join Lab_Employee_Custom_Column on Lab_Exception.employee_id = Lab_Employee_Custom_Column.employee_id "
    else
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "inner join Lab_Employee_Attribute_List on Lab_Exception.employee_id = Lab_Employee_Attribute_List.employee_id " +
:           "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id "
    endif

    WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:        "where Lab_Exception.business_date between '" +
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ + "' "

    if useCustomColumnTableForShift then
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "and Lab_Employee_Custom_Column.custom_column_def_id = " + customColumnDefIdForShift$ + " "
    else
        WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:           "and Lab_Employee_Attribute_List.end_date is null " +
:           "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) "
    endif

    WFMR_EXCEPTIONS_SELECT_STMT$ = WFMR_EXCEPTIONS_SELECT_STMT$ +
:        "and Lab_Exception.exception_definition_id in("+
:        exceptionIdsAsCSV$ +
:        ") " +
:        "and Lab_Job.name not like '%Supervisor%' " +
:        "order by exception_date, shift, last_name, first_name "
    
    
    REM  VERY IMPORTANT: Do not use apostrophes around ? symbols -- even for character fields
    
    ATTEND_PTS_EXCEPTIONS_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ?"
    
    ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set exc_gone_stamp = '', last_mod = ?, last_mod_user = ?, dept_id = ?, shift = ?, emp_id = ?, emp_badge_no = ?, sched_shift_id = ?, job_id = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ? and (wfmr_exc_lastmod < ? or exc_gone_stamp > '')"


    REM  Probably could have parameterized the following query with ?

    WFMR_MISSED_SHIFT_SELECT_STMT$ = 
:       "select " +
:       "convert(varchar(19), Lab_Employee_Missed_Shifts.in_timestamp, 120) as in_timestamp, " +
:        "Lab_Employee_Missed_Shifts.business_unit_id, " +
:        "Lab_Job.department_id, "

    if useCustomColumnTableForShift then
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:           "Lab_Employee_Custom_Column.column_value as shift, "
    else
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:           "Lab_Employee_Attribute.attribute_code as shift, "
    
    endif
    
    WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:        "Lab_Employee_Missed_Shifts.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Employee_Missed_Shifts.scheduled_shift_id, " +
:        "Lab_Employee_Missed_Shifts.job_id, " +
:        "convert(varchar(8), Lab_Employee_Missed_Shifts.business_date, 112) as missed_shift_date, " +
:        "Lab_Employee_Missed_Shifts.type_code, " +
:        "convert(varchar(19), Lab_Employee_Missed_Shifts.last_modified_timestamp, 120) as missed_shift_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name, " +
:        "case when Lab_Employee_Missed_Shifts.reason_id is null then 0 else Lab_Employee_Missed_Shifts.reason_id end as reason_id, " +
:        "case when Reason.name is null then '' else Reason.name end as reason_name " +
:        "from Lab_Employee_Missed_Shifts " +
:        "inner join Rad_Sys_User on Lab_Employee_Missed_Shifts.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Employee_Missed_Shifts.employee_id = Employee.employee_id " +
:        "inner join Lab_Job on Lab_Employee_Missed_Shifts.job_id = Lab_Job.job_id "

    if useCustomColumnTableForShift then
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ +
:           "inner join Lab_Employee_Custom_Column on Lab_Employee_Missed_Shifts.employee_id = Lab_Employee_Custom_Column.employee_id "
    else
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ +
:           "inner join Lab_Employee_Attribute_List on Lab_Employee_Missed_Shifts.employee_id = Lab_Employee_Attribute_List.employee_id " +
:           "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id "
    endif 
    
    WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:        "left join Reason on Lab_Employee_Missed_Shifts.reason_id = Reason.reason_id " +
:        "where " + 
:        "Lab_Employee_Missed_Shifts.business_date between '" + 
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ + "' "

    if useCustomColumnTableForShift then
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:           "and Lab_Employee_Custom_Column.custom_column_def_id = " + customColumnDefIdForShift$ + " "
    else
        WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:           "and Lab_Employee_Attribute_List.end_date is null " +
:           "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) "
    endif
    
    WFMR_MISSED_SHIFT_SELECT_STMT$ = WFMR_MISSED_SHIFT_SELECT_STMT$ + 
:        "and Lab_Employee_Missed_Shifts.type_code in('c','n') " +
:        "and Lab_Job.name not like '%Supervisor%' " +
:        "order by missed_shift_date, shift, last_name, first_name"


    ATTEND_PTS_MISSED_SHIFT_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ?"

    ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set exc_gone_stamp = '', last_mod = ?, last_mod_user = ?, dept_id = ?, shift = ?, emp_badge_no = ?, sched_shift_id = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ?, wfmr_reason_id = ? " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ? " +
:        "and (wfmr_exc_lastmod < ? or exc_gone_stamp > '')"

    ATTEND_PTS_WORK_GET_TOTALS_STMT$ = 
:       "select wfmr_exc_date, count(*) as total " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? " +
:       "and exc_gone_stamp = '' and exc_dup_stamp = '' " +
:       "group by wfmr_exc_date " +
:       "order by wfmr_exc_date desc"

    ATTEND_PTS_WORK_GET_POSTED_STMT$ = 
:       "select wfmr_exc_date, posted_timestamp, count(*) as posted_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? " +
:       "and exc_gone_stamp = '' and exc_dup_stamp = '' " +
:       "group by wfmr_exc_date, posted_timestamp"

    ATTEND_PTS_WORK_GET_DISPOSITION_STMT$ = 
:       "select wfmr_exc_date, disp_cd, count(*) as disp_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? " +
:       "and exc_gone_stamp = '' and exc_dup_stamp = '' " +
:       "group by wfmr_exc_date, disp_cd"

    ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$ = 
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.WFMR_EXC_DEF_ID, " +
:       "attend_pts_work.sched_shift_id, " +
:       "attend_pts_work.WFMR_PTS_ASSESS, " +
:       "attend_pts_work.POSTED_TIMESTAMP, " +
:       "attend_pts_work.WFMR_EXC_LASTMOD, " +
:       "attend_pts_work.ERP_CD, " +
:       "attend_pts_work.ERP_PTS_ASSESSED, " +
:       "attend_pts_work.ERP_NOTE " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "where " + 
:       "attend_pts_work.dept_id = ? and attend_pts_work.wfmr_exc_date = ? and attend_pts_work.shift = ? " +
:       "and exc_gone_stamp = '' and exc_dup_stamp = '' " +
:       "order by last_first_mi"

    ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$ = 
:       "update attend_pts_work " +
:       "set disp_cd = ?, disp_edt_reas_id = ?, erp_cd = ?, erp_note = ?, erp_pts_assessed = ?, " +
:       "erp_sts_cd = ?, last_mod = ?, last_mod_user = ? " +
:       "where id = ?"

    ATTEND_PTS_WORK_UPDATE_POSTED_FLAG_STMT$ = 
:       "update attend_pts_work " +
:       "set posted_timestamp = ?, posted_by_user = ?, posted_exc_defid = ? " +
:       "where id = ?"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_STMT$ =
:       "select id, wfmr_exc_id from attend_pts_work where wfmr_src = 'E' and disp_cd = 'N'"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_SKIP_FLAGGED_STMT$ =
:       "select id, wfmr_exc_id from attend_pts_work where wfmr_src = 'E' and disp_cd = 'N' " +
:       "and exc_gone_stamp = '' and exc_dup_stamp = ''"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_MISSED_SHIFTS_STMT$ =
:       "select id, emp_id, bus_unit_id, job_id, wfmr_in_tm_miss from attend_pts_work " +
:       "where wfmr_src = 'M' and disp_cd = 'N'"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_MISSED_SHIFTS_SKIP_FLAGGED_STMT$ =
:       "select id, emp_id, bus_unit_id, job_id, wfmr_in_tm_miss from attend_pts_work " +
:       "where wfmr_src = 'M' and disp_cd = 'N' and exc_gone_stamp = '' and exc_dup_stamp = ''"

    ATTEND_PTS_WORK_FLAG_THAT_WFMR_RECORD_NO_LONGER_EXISTS_STMT$ =
:       "update attend_pts_work set exc_gone_stamp = ? where id = ?"

    GET_MOST_RECENT_EXCEPTION_DATE_LOADED_STMT$ =
:       "select top 1 WFMR_EXC_DATE from attend_pts_work order by WFMR_EXC_DATE desc"

    GET_COUNT_BY_DATE_AND_SRC_STMT$ =
:       "select " +
:       "WFMR_EXC_DATE, WFMR_SRC, count(*) as qty " +
:       "from ATTEND_PTS_WORK " +
:       "where WFMR_EXC_DATE >= ? and WFMR_EXC_DATE <= ? " +
:       "group by WFMR_EXC_DATE, WFMR_SRC"

    GET_COUNT_AND_DATA_FOR_DUP_EXCEPTIONS_STMT$ = 
:       "select " + 
:       "attend_pts_work.WFMR_EXC_DATE, " +
:       "attend_pts_work.EMP_BADGE_NO, " +
:       "attend_pts_work.SCHED_SHIFT_ID, " +
:       "attend_pts_work.WFMR_EXC_DEF_ID, " +
:       "count(*) as dup_count " +
:       "from attend_pts_work " +
:       "where " +
:       "attend_pts_work.WFMR_SRC = 'E' " +
:       "and attend_pts_work.EXC_GONE_STAMP = '' " +
:       "and attend_pts_work.EXC_DUP_STAMP = '' " +
:       "and attend_pts_work.WFMR_EXC_DATE >= ? " +
:       "and attend_pts_work.WFMR_EXC_DATE <= ? " +
:       "group by " + 
:       "attend_pts_work.WFMR_EXC_DATE, " + 
:       "attend_pts_work.EMP_BADGE_NO, " +
:       "attend_pts_work.SCHED_SHIFT_ID, " +
:       "attend_pts_work.WFMR_EXC_DEF_ID " +
:       "having count(*) > 1"

    GET_ROWS_PER_DATE_AND_EMPLOYEE_WITH_DUP_EXCEPTIONS_STMT$ = 
:       "select " + 
:       "id, " +
:       "disp_cd, " +
:       "posted_timestamp, " +
:       "last_mod " +
:       "from attend_pts_work " +
:       "where " +
:       "WFMR_EXC_DATE = ? " +
:       "and EMP_BADGE_NO = ? " +
:       "and sched_shift_id = ? " +
:       "and wfmr_exc_def_id = ? " +
:       "and EXC_GONE_STAMP = '' " +
:       "and EXC_DUP_STAMP = '' " +
:       "order by " +
:       "posted_timestamp desc, " +
:       "last_mod desc"

    FLAG_AS_WFMR_EXCEPTION_DUPLICATE_STMT$ =
:       "update attend_pts_work set exc_dup_stamp = ? where id = ?"

    return
    
    
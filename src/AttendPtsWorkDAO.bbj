REM /**
REM  * AttendPtsWorkDAO.bbj
REM  * @author stevett
REM  * 
REM  * Written: July 2015
REM  * 
REM  * Description: Data Access Object for table ATTEND_PTS_WORK
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap
use java.util.Vector

declare java.util.LinkedHashMap datesMapOut!
declare java.util.HashMap dateQtysMap!

declare java.util.LinkedHashMap employeesMapOut!
declare java.util.HashMap employeeDataMap!

declare java.util.LinkedHashMap attPtsRecordsMapOut!
declare java.util.HashMap attPtsWorkDataMap!

declare java.util.Vector attPtsWorkIds!

declare java.util.HashMap minimalExceptionRecordsMap!
declare java.util.HashMap minimalExceptionsDataMap!

declare java.util.LinkedHashMap attPtsRecordsToFlagMap!


rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:

def fnIsMassLoadingExceptions(aDoIt)
    return massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
fnend


def fnGetLoginUser$(aDoIt)
    tmpUser$ = info(3, 2)
    
    if len(tmpUser$) > 10 then tmpUser$ = tmpUser$(1,10)
    
    return tmpUser$
fnend


rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


mass_load_wfmr_data:

    REM  Business dates are in format like this: "2015-07-15"

    enter businessDateFromIn$, businessDateToIn$
    
    gosub setup_constants
    
    loginUser$ = fnGetLoginUser$(TRUE)
    
    massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
    gosub run_mass_load
    
    massLoadSrc$ = MASS_LOAD_MISSED_SHIFT_SRC$
    gosub run_mass_load
    
    exit


get_dates_with_totals:

    enter shiftIn$, deptIdIn, fromDateIn, toDateIn, datesMapOut!
    
    gosub setup_constants
    
    gosub load_dates_map
    
    exit


get_employees_for_date:

    enter shiftIn$, deptIdIn, dateIn!, employeesMapOut!
    
    gosub setup_constants
    
    gosub load_employees_map
    
    exit


get_records_by_ids_in_list:

    enter attPtsWorkIds!, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub load_work_records_map
    
    exit


get_records_where_exceptions_no_longer_exist:

    enter skipAlreadyFlaggedOnes, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub get_work_records_map_where_exceptions_no_longer_exist
    
    exit


flag_records_where_exceptions_no_longer_exist:

    enter attPtsRecordsToFlagMap!
    
    gosub setup_constants
    
    gosub flag_work_records_map_where_exceptions_no_longer_exist
    
    exit


save_one_record:

    enter attPtsWorkDataMap!
    
    gosub setup_constants
    
    gosub save_record_from_map
    
    exit
    
    
open_and_prep_channel_to_flag_posting:

    enter flagPostingChannelOut
    
    gosub setup_constants

    flagPostingChannelOut = sqlunt
    sqlopen(flagPostingChannelOut) attendPtsDataSource$
    sqlprep(flagPostingChannelOut) ATTEND_PTS_WORK_UPDATE_POSTED_FLAG_STMT$
    
    exit

    
flag_posting:

    enter flagPostingChannelIn, recordIdIn, userIdIn$, wfmrExceptionDefIdIn
    
    gosub setup_constants
    
    gosub update_posted_flag_on_record
    
    exit
    
    
close_channel_to_flag_posting:

    enter flagPostingChannelIn
    
    sqlclose(flagPostingChannelIn)
    
    exit
    

rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------------------------------------
REM  Mass load WFMR exception and missed shift data
REM  ------------------------------------------------------------------------------------------

run_mass_load:

    gosub ml_init
    gosub ml_open_sql_channels
    gosub ml_prepare_sql_stmts
    gosub ml_process_wfmr_data
    gosub ml_close_sql_channels

    return


REM  ------------------------------------------------------------------------------------------
REM  Define constants
REM  ------------------------------------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0
    
    ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$ = "current.attend.pts.policy.code"
    
    MASS_LOAD_EXCEPTIONS_SRC$ = "E"
    MASS_LOAD_MISSED_SHIFT_SRC$ = "M"
    
    PRINT_TRACE_INFO = FALSE
    BATCH_SIZE = 500
    
    DEFAULT_DISPOSITION_CODE$ = "N"
    DEFAULT_DISPOSITION_EDIT_REASON_ID = 0
    DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ = ""
    DEFAULT_LAST_MANUALLY_MODIFIED_USER$ = ""
    DEFAULT_POSTED_TIMESTAMP$ = ""
    DEFAULT_POSTED_USER$ = ""
    
    REM Uses the data source names in the SQL.INI file
    
    attendPtsDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$
    
    wfmrDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "wfmr.data.source.name", configVarFound, configVarDataType$, wfmrDataSource$
    
    attendPtsPolicyCode$ = ""
    call "ConfigVarsDAO.bbj::get_value", ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$, configVarFound, configVarDataType$, attendPtsPolicyCode$

    call "AttendPtsTransDAO.bbj::get_exception_ids_as_csv", attendPtsPolicyCode$, exceptionIdsAsCSV$

    
    REM  Break up field list into 5 fields per row (so readable)
       
    STARTING_INSERT_STMT$ =
:        "insert into ATTEND_PTS_WORK " +
:        "(id, wfmr_src, wfmr_exc_id, wfmr_in_tm_miss, bus_unit_id, " +
:        "dept_id, shift, emp_id, emp_badge_no, job_id, " +
:        "wfmr_exc_date, wfmr_exc_def_id, wfmr_pts_assess, wfmr_exc_lastmod, disp_cd, " +
:        "disp_edt_reas_id, erp_cd, erp_note, erp_pts_assessed, erp_sts_cd, " +
:        "last_mod, last_mod_user, posted_timestamp, posted_by_user, posted_exc_defid, " +
:        "wfmr_reason_id, exc_gone_stamp, sched_shift_id) " +
:        "values "


    REM  Probably could have parameterized the following query with ?

    WFMR_EXCEPTIONS_SELECT_STMT$ = 
:       "select " +
:        "Lab_Exception.exception_id, " +
:        "Lab_Exception.business_unit_id, " +
:        "Lab_Job.department_id, " +
:        "Lab_Employee_Attribute.attribute_code as shift, " +
:        "Lab_Exception.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Exception.scheduled_shift_id, " +
:        "Lab_Exception.job_id, " +
:        "convert(varchar(8), Lab_Exception.business_date, 112) as exception_date, " +
:        "Lab_Exception.exception_definition_id, " +
:        "Lab_Exception_Definition.name as exception_descr, " +
:        "convert(varchar(19), Lab_Exception.last_modified_timestamp, 120) as exception_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name " +
:        "from Lab_Exception " + 
:        "inner join Lab_Exception_Definition on Lab_Exception.exception_definition_id = Lab_Exception_Definition.exception_definition_id " + 
:        "inner join Rad_Sys_User on Lab_Exception.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Exception.employee_id = Employee.employee_id " + 
:        "inner join Lab_Punch_Shift on Lab_Exception.shift_start_punch_id = Lab_Punch_Shift.shift_start_punch_id " +
:        "inner join Lab_Job on Lab_Exception.job_id = Lab_Job.job_id " + 
:        "inner join Lab_Employee_Attribute_List on Lab_Exception.employee_id = Lab_Employee_Attribute_List.employee_id " +
:        "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id " +
:        "where Lab_Exception.business_date between '" +
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ +
:        "' and Lab_Employee_Attribute_List.end_date is null " +
:        "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) " +
:        "and Lab_Exception.exception_definition_id in("+
:        exceptionIdsAsCSV$ +
:        ") " +
:        "and Lab_Job.name not like '%Supervisor%' " +
:        "order by exception_date, shift, last_name, first_name "
    
    
    REM  VERY IMPORTANT: Do not use apostrophes around ? symbols -- even for character fields
    
    ATTEND_PTS_EXCEPTIONS_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ?"
    
    ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set dept_id = ?, shift = ?, emp_id = ?, emp_badge_no = ?, sched_shift_id = ?, job_id = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ? and wfmr_exc_lastmod < ?"


    REM  Probably could have parameterized the following query with ?

    WFMR_MISSED_SHIFT_SELECT_STMT$ = 
:       "select " +
:       "convert(varchar(19), Lab_Employee_Missed_Shifts.in_timestamp, 120) as in_timestamp, " +
:        "Lab_Employee_Missed_Shifts.business_unit_id, " +
:        "Lab_Job.department_id, " +
:        "Lab_Employee_Attribute.attribute_code as shift, " +
:        "Lab_Employee_Missed_Shifts.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Employee_Missed_Shifts.scheduled_shift_id, " +
:        "Lab_Employee_Missed_Shifts.job_id, " +
:        "convert(varchar(8), Lab_Employee_Missed_Shifts.business_date, 112) as missed_shift_date, " +
:        "Lab_Employee_Missed_Shifts.type_code, " +
:        "convert(varchar(19), Lab_Employee_Missed_Shifts.last_modified_timestamp, 120) as missed_shift_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name, " +
:        "case when Lab_Employee_Missed_Shifts.reason_id is null then 0 else Lab_Employee_Missed_Shifts.reason_id end as reason_id, " +
:        "case when Reason.name is null then '' else Reason.name end as reason_name " +
:        "from Lab_Employee_Missed_Shifts " +
:        "inner join Rad_Sys_User on Lab_Employee_Missed_Shifts.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Employee_Missed_Shifts.employee_id = Employee.employee_id " +
:        "inner join Lab_Job on Lab_Employee_Missed_Shifts.job_id = Lab_Job.job_id " + 
:        "inner join Lab_Employee_Attribute_List on Lab_Employee_Missed_Shifts.employee_id = Lab_Employee_Attribute_List.employee_id " +
:        "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id " +
:        "left join Reason on Lab_Employee_Missed_Shifts.reason_id = Reason.reason_id " +
:        "where " + 
:        "Lab_Employee_Missed_Shifts.business_date between '" + 
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ +
:        "' and Lab_Employee_Attribute_List.end_date is null " +
:        "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) " +
:        "and Lab_Employee_Missed_Shifts.type_code in('c','n') " +
:        "and Lab_Job.name not like '%Supervisor%' " +
:        "order by missed_shift_date, shift, last_name, first_name"


    ATTEND_PTS_MISSED_SHIFT_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ?"

    ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set dept_id = ?, shift = ?, emp_badge_no = ?, sched_shift_id = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ?, wfmr_reason_id = ? " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ? " +
:        "and wfmr_exc_lastmod < ?"

    ATTEND_PTS_WORK_GET_TOTALS_STMT$ = 
:       "select wfmr_exc_date, count(*) as total " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? and exc_gone_stamp = '' " +
:       "group by wfmr_exc_date " +
:       "order by wfmr_exc_date desc"

    ATTEND_PTS_WORK_GET_POSTED_STMT$ = 
:       "select wfmr_exc_date, posted_timestamp, count(*) as posted_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? and exc_gone_stamp = '' " +
:       "group by wfmr_exc_date, posted_timestamp"

    ATTEND_PTS_WORK_GET_DISPOSITION_STMT$ = 
:       "select wfmr_exc_date, disp_cd, count(*) as disp_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and wfmr_exc_date <= ? and shift = ? and exc_gone_stamp = '' " +
:       "group by wfmr_exc_date, disp_cd"

    ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$ = 
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.WFMR_EXC_DEF_ID, " +
:       "attend_pts_work.sched_shift_id, " +
:       "attend_pts_work.WFMR_PTS_ASSESS, " +
:       "attend_pts_work.POSTED_TIMESTAMP, " +
:       "attend_pts_work.WFMR_EXC_LASTMOD, " +
:       "attend_pts_work.ERP_CD, " +
:       "attend_pts_work.ERP_PTS_ASSESSED, " +
:       "attend_pts_work.ERP_NOTE " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "where " + 
:       "attend_pts_work.dept_id = ? and attend_pts_work.wfmr_exc_date = ? and attend_pts_work.shift = ? and exc_gone_stamp = '' " +
:       "order by last_first_mi"

    ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$ = 
:       "update attend_pts_work " +
:       "set disp_cd = ?, disp_edt_reas_id = ?, erp_cd = ?, erp_note = ?, erp_pts_assessed = ?, " +
:       "erp_sts_cd = ?, last_mod = ?, last_mod_user = ? " +
:       "where id = ?"

    ATTEND_PTS_WORK_UPDATE_POSTED_FLAG_STMT$ = 
:       "update attend_pts_work " +
:       "set posted_timestamp = ?, posted_by_user = ?, posted_exc_defid = ? " +
:       "where id = ?"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_STMT$ =
:       "select id, wfmr_exc_id from attend_pts_work where wfmr_src = 'E' and disp_cd = 'N'"

    ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_SKIP_FLAGGED_STMT$ =
:       "select id, wfmr_exc_id from attend_pts_work where wfmr_src = 'E' and disp_cd = 'N' and exc_gone_stamp = ''"

    ATTEND_PTS_WORK_FLAG_THAT_WFMR_EXCEPTION_NO_LONGER_EXISTS_STMT$ =
:       "update attend_pts_work set exc_gone_stamp = ? where id = ?"

    return

REM  ------------------------------------------------------------------------------------------
REM  Mass Load Init
REM  ------------------------------------------------------------------------------------------

ml_init:

    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$
    
    if fnIsMassLoadingExceptions(TRUE) then
        wfmrSelectStmt$ = WFMR_EXCEPTIONS_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_EXCEPTIONS_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$
    else
        wfmrSelectStmt$ = WFMR_MISSED_SHIFT_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_MISSED_SHIFT_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$
    endif
    
    totalInserted = 0
    
    readCount = 0
    insertCount = 0
    batchNo = 0

    return


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Open SQL Channels
REM  ------------------------------------------------------------------------------------------

ml_open_sql_channels:

    attendPtsFindRowChannel = sqlunt
    sqlopen(attendPtsFindRowChannel) attendPtsDataSource$
    
    attendPtsInsertRowsChannel = sqlunt
    sqlopen(attendPtsInsertRowsChannel) attendPtsDataSource$
    
    attendPtsUpdateRowChannel = sqlunt
    sqlopen(attendPtsUpdateRowChannel) attendPtsDataSource$
    
    wfmrSelectRowsChannel = sqlunt
    sqlopen(wfmrSelectRowsChannel) wfmrDataSource$
    
    return; rem 1


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Prepare SQL Statements
REM  ------------------------------------------------------------------------------------------

ml_prepare_sql_stmts:

    sqlprep(attendPtsFindRowChannel) attendPtsFindStmt$
    sqlprep(attendPtsUpdateRowChannel) attendPtsUpdateStmt$
    sqlprep(wfmrSelectRowsChannel) wfmrSelectStmt$
    
    print $0A$,"AttendPtsWorkDAO.bbj - ml_prepare_sql_stmts. wfmrSelectStmt$ = "
    print wfmrSelectStmt$

    return; rem 2


REM  ------------------------------------------------------------------------------------------
REM  Mass Load Process WFMR Data
REM  ------------------------------------------------------------------------------------------

ml_process_wfmr_data:

    sqlexec(wfmrSelectRowsChannel)
    
    dim wfmrResultRow$:sqltmpl(wfmrSelectRowsChannel)
    
    while TRUE

        REM  "while", "repeat" and "for" use same stack as gosub, so requires exitto.  "break" may work.  For BBj, *break on err= works.
    
        wfmrResultRow$ = sqlfetch(wfmrSelectRowsChannel,err=*break)
        
        readCount = readCount + 1
        
        hits = 0
        
        if fnIsMassLoadingExceptions(TRUE) then
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.exception_id
        else
            tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$ 
        endif
        
        dim ptsResultRow$:sqltmpl(attendPtsFindRowChannel)
        ptsResultRow$ = sqlfetch(attendPtsFindRowChannel,err=hit_check_bombed)
        hits = ptsResultRow.hit_count
        hit_check_bombed:
        
        if !(fnIsMassLoadingExceptions(TRUE)) then
            if wfmrResultRow.type_code$ = "n" then 
                derived_exception_id = 11
                else 
                if wfmrResultRow.type_code$ = "c" then derived_exception_id = 46
            endif
        endif
 
        
        if PRINT_TRACE_INFO and readCount < 2 then
            if fnIsMassLoadingExceptions(TRUE) then 
                print "exception_id = ", wfmrResultRow.exception_id
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "exception_date = ", wfmrResultRow.exception_date$
                print "exception_definition_id = ", wfmrResultRow.exception_definition_id
                print "exception_descr = ", wfmrResultRow.exception_descr$
                print "exception_last_mod = ", wfmrResultRow.exception_last_mod$
                print "hits = ", hits
                print $0A$
            else
                print "in_timestamp = ", wfmrResultRow.in_timestamp$
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "missed_shift_date = ", wfmrResultRow.missed_shift_date$
                print "derived_exception_id = ", derived_exception_id
                print "missed_shift_last_mod = ", wfmrResultRow.missed_shift_last_mod$
                print "hits = ", hits
                print $0A$
            endif
        endif
        
        if hits = 0 then
           gosub ml_add_to_insert_batch
        else
           gosub ml_update_row
        endif
        
    wend

    return; rem 3
    

REM  ------------------------------------------------------------------------------------------
REM  Mass Load Update a Row
REM  ------------------------------------------------------------------------------------------

ml_update_row:
    
    REM  IMPORTANT: Was getting error 77 SQL before I added "cvs" to trim trailing blanks -- due to field being too long.

REM     ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$ = 
REM :        "update attend_pts_work " + 
REM :        "set dept_id = ?, shift = ?, emp_id = ?, emp_badge_no = ?, job_id = ?, " + 
REM :        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
REM :        "where wfmr_src = 'E' and wfmr_exc_id = ? and wfmr_exc_lastmod < ?"
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel) 
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), wfmrResultRow.employee_id, 
:           cvs(wfmrResultRow.badge_number$, 2), wfmrResultRow.scheduled_shift_id, wfmrResultRow.job_id,
:           wfmrResultRow.exception_date$, wfmrResultRow.exception_definition_id, str(erpPts), tempLastModDate$,
:           wfmrResultRow.exception_id, tempLastModDate$
    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) 
        tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel) 
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), cvs(wfmrResultRow.badge_number$, 2), wfmrResultRow.scheduled_shift_id,
:           wfmrResultRow.missed_shift_date$, derived_exception_id, str(erpPts), tempLastModDate$, wfmrResultRow.reason_id,
:           wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$,
:           tempLastModDate$  
    endif

    return; rem 4
    

REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Add a values phrase to an Insert Statement
REM  ------------------------------------------------------------------------------------------

ml_add_to_insert_batch:

    insertCount = insertCount + 1
    
    if insertCount > 1 then attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + ","
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'E', " +
:          str(wfmrResultRow.exception_id) + ", " +
:          "0, " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.exception_date$ + "', " +
:          str(wfmrResultRow.exception_definition_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "', " + 
:          "0, " +
:          "0, " +
:          "'', " +
:          str(wfmrResultRow.scheduled_shift_id) + 
:          ")"

    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$

        REM  If a reason code has been entered on the missed shift record, tack a description onto the erpNote$
        
        reasonName$ = cvs(wfmrResultRow.reason_name$, 2)
        
        if len(reasonName$) > 0 then
            erpNote$ = cvs(erpNote$, 2) + " - " + reasonName$
        endif
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'M', " +
:          "0, " +
:          "'" + wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) + "', " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.missed_shift_date$ + "', " +
:          str(derived_exception_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "', " + 
:          "0, " +
:          str(wfmrResultRow.reason_id) + ", " +
:          "'', " +
:          str(wfmrResultRow.scheduled_shift_id) + 
:          ")"
    endif
    
    attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + valuesClause$ 

    if insertCount = BATCH_SIZE then gosub ml_write_batch

    return; rem 5


REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Write the Insert Batch
REM  ------------------------------------------------------------------------------------------

ml_write_batch:

    batchNo = batchNo + 1
    
    print "batchNo = ", batchNo

    sqlprep(attendPtsInsertRowsChannel) attendPtsDynamicInsertStmt$
    sqlexec(attendPtsInsertRowsChannel)
    
    totalInserted = totalInserted + insertCount
    
    insertCount = 0
    
    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$

    return; rem 6


REM  ------------------------------------------------------------------------------------------
REM  Mass Load: Close SQL Channels
REM  ------------------------------------------------------------------------------------------

ml_close_sql_channels:

    sqlclose(wfmrSelectRowsChannel)
    
    if insertCount > 0 then gosub ml_write_batch
    
    sqlclose(attendPtsFindRowChannel)
    sqlclose(attendPtsInsertRowsChannel)
    sqlclose(attendPtsUpdateRowChannel)

    return; rem 7    


REM  ------------------------------------------------------------------------------------------
REM  Load one set of info per work file date into the datesMapOut!
REM  ------------------------------------------------------------------------------------------
    
load_dates_map:
    
    datesMapOut!.clear()
    
    REM  Step 1. Query the ATTEND_PTS_WORK file: populate totals
    
    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_TOTALS_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        dateQtysMap! = new java.util.HashMap()
        dateQtysMap!.put("total", resultRow.total)
        dateQtysMap!.put("posted", 0)
        
        REM  In following, key is disposition code:
        dateQtysMap!.put("A", 0)
        dateQtysMap!.put("E", 0)
        dateQtysMap!.put("F", 0)
        dateQtysMap!.put("N", 0)

        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend

    
    REM  Step 2. Query the ATTEND_PTS_WORK file: populate posted/not posted
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_POSTED_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        if !(cvs(resultRow.posted_timestamp$, 3) = "") then
            dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
            posted = dateQtysMap!.get("posted")
            posted = posted + resultRow.posted_count
            dateQtysMap!.put("posted", posted)
            datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        endif
        
    wend

    
    REM  Step 3. Query the ATTEND_PTS_WORK file: populate disposition status
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_DISPOSITION_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDateIn, toDateIn, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
        
        tmpTotal = dateQtysMap!.get(resultRow.disp_cd$)
        tmpTotal = tmpTotal + resultRow.disp_count
        dateQtysMap!.put(resultRow.disp_cd$, tmpTotal)
        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)


    return


REM  ------------------------------------------------------------------------------------------
REM  For one date, Load a set of info per employee into the employeesMapOut!
REM  ------------------------------------------------------------------------------------------
    
load_employees_map:

    employeesMapOut!.clear()

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, dateIn!, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        employeeDataMap! = new java.util.HashMap()
        employeeDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        employeeDataMap!.put("disp_cd", resultRow.disp_cd$)
        employeeDataMap!.put("sched_shift_id", resultRow.sched_shift_id)
        employeeDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        employeeDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        employeeDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        employeeDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        employeeDataMap!.put("erp_cd", resultRow.erp_cd$)
        employeeDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        employeeDataMap!.put("erp_note", resultRow.erp_note$)

        employeesMapOut!.put(resultRow.id, employeeDataMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Load a set of info into the attPtsRecordsMapOut! -- but only for
REM  records that no longer exist in the WFMR Lab_Exceptions table.
REM  ------------------------------------------------------------------------------------------


get_work_records_map_where_exceptions_no_longer_exist:

    REM  Step 1. Get all punch exceptions in the ATTEND_PTS_WORK table
    
    minimalExceptionsChannel = sqlunt
    sqlopen(minimalExceptionsChannel) attendPtsDataSource$
    
    if skipAlreadyFlaggedOnes then
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_SKIP_FLAGGED_STMT$
    else
        sqlprep(minimalExceptionsChannel) ATTEND_PTS_WORK_GET_NOT_HANDLED_PUNCH_EXCEPTIONS_STMT$
    endif

    sqlexec(minimalExceptionsChannel) 
    dim resultRow$:sqltmpl(minimalExceptionsChannel)
        
    minimalExceptionRecordsMap! = new java.util.HashMap()
    
    while TRUE
    
        resultRow$ = sqlfetch(minimalExceptionsChannel,err=*break)
        minimalExceptionsDataMap! = new java.util.HashMap()
        minimalExceptionsDataMap!.put("wfmr_exception_id", resultRow.wfmr_exc_id)
        minimalExceptionRecordsMap!.put(resultRow.id, minimalExceptionsDataMap!)
        
    wend
    
    sqlclose(minimalExceptionsChannel)

    
    REM  Step 2. Check to see if any of the punch exceptions are missing in WFMR.  If so,
    REM          add ATTEND_PTS_WORK ID to attPtsWorkIds! vector. 
    
    call "WFMRExceptionDAO.bbj::append_missing_exception_info_to_map", minimalExceptionRecordsMap!
    
    attPtsWorkIds! = new java.util.Vector()
    
    iter! = minimalExceptionRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        minimalExceptionsDataMap! = cast( java.util.HashMap, minimalExceptionRecordsMap!.get(idKey!) )
        
        if minimalExceptionsDataMap!.containsKey("missing_in_wfmr") then
            attPtsWorkIds!.add(idKey!)
        endif

    wend
    
    
    REM  Step 3. For all IDs in the attPtsWorkIds! vector, load the map of attendance point records (to return)

    attPtsRecordsMapOut!.clear()

    if attPtsWorkIds!.size() > 0 then
        gosub load_work_records_map
    endif

    return


REM  ------------------------------------------------------------------------------------------
REM  Flag all records in attPtsRecordsToFlagMap! with current timestamp
REM  ------------------------------------------------------------------------------------------
    
    
flag_work_records_map_where_exceptions_no_longer_exist:

    flagChannel = sqlunt
    sqlopen(flagChannel) attendPtsDataSource$
    sqlprep(flagChannel) ATTEND_PTS_WORK_FLAG_THAT_WFMR_EXCEPTION_NO_LONGER_EXISTS_STMT$
    
    call "DateUtilities.bbj::get_current_timestamp", currentTimestamp$

    iter! = attPtsRecordsToFlagMap!.keySet().iterator()
    
    while iter!.hasNext()
        idKey! = iter!.next()
        sqlexec(flagChannel) currentTimestamp$, idKey! 
    wend
    
    sqlclose(flagChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  For each id in list, load a set of info into the attPtsRecordsMapOut!
REM  ------------------------------------------------------------------------------------------

    
load_work_records_map:

    attPtsRecordsMapOut!.clear()
    
    REM  Build CSV list of ids from incoming vector:
    
    inClause$ = ""
    
    idCount = attPtsWorkIds!.size()
    
    for i = 0 to idCount - 1
    
        if i > 0 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + str( attPtsWorkIds!.get(i) ) 
         
    next i
    
    REM  Unfortunately, you can't use a single ? parm in a prepared query for a list of ids

    attendPtsWorkGetRecordsByIdListStmt$ =
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.emp_badge_no, " +
:       "attend_pts_work.wfmr_exc_id, " +
:       "attend_pts_work.wfmr_exc_date, " +
:       "attend_pts_work.sched_shift_id, " +
:       "attend_pts_work.job_id, " +
:       "attend_pts_work.wfmr_exc_def_id, " +
:       "attend_pts_work.wfmr_reason_id, " +
:       "attend_pts_work.wfmr_pts_assess, " +
:       "attend_pts_work.wfmr_exc_lastmod, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.disp_edt_reas_id, " +
:       "attend_pts_reasn.descr as edt_reas_descr, " +
:       "attend_pts_work.erp_cd, " +
:       "attend_pts_work.erp_note, " +
:       "attend_pts_work.erp_pts_assessed, " +
:       "attend_pts_work.erp_sts_cd, " +
:       "attend_pts_work.last_mod, " +
:       "attend_pts_work.last_mod_user, " +
:       "attend_pts_work.posted_timestamp, " +
:       "attend_pts_work.posted_by_user, " +
:       "attend_pts_work.posted_exc_defid " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "left join attend_pts_reasn on attend_pts_reasn.id = attend_pts_work.disp_edt_reas_id " +
:       "where id in(" +
:       inClause$ +
:       ")"

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) attendPtsWorkGetRecordsByIdListStmt$
    

    sqlexec(attendPtsWorkDatesChannel)  
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)

    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        attPtsWorkDataMap! = new java.util.HashMap()
        
        attPtsWorkDataMap!.put("id", resultRow.id)
        attPtsWorkDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        attPtsWorkDataMap!.put("emp_badge_no", resultRow.emp_badge_no$)
        attPtsWorkDataMap!.put("wfmr_exc_id", resultRow.wfmr_exc_id)
        attPtsWorkDataMap!.put("wfmr_exc_date", resultRow.wfmr_exc_date$)
        attPtsWorkDataMap!.put("sched_shift_id", resultRow.sched_shift_id)
        attPtsWorkDataMap!.put("job_id", resultRow.job_id)
        attPtsWorkDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        attPtsWorkDataMap!.put("wfmr_reason_id", resultRow.wfmr_reason_id)
        attPtsWorkDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        attPtsWorkDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        attPtsWorkDataMap!.put("disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("edt_reas_descr", resultRow.edt_reas_descr$)
        attPtsWorkDataMap!.put("erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("erp_sts_cd", resultRow.erp_sts_cd$)
        attPtsWorkDataMap!.put("last_mod", resultRow.last_mod$)
        attPtsWorkDataMap!.put("last_mod_user", resultRow.last_mod_user$)
        attPtsWorkDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        attPtsWorkDataMap!.put("posted_by_user", resultRow.posted_by_user$)
        attPtsWorkDataMap!.put("posted_exc_defid", resultRow.posted_exc_defid)
        
        REM  Save original values of editable ERP fields:

        attPtsWorkDataMap!.put("orig_disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("orig_disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("orig_erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("orig_erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("orig_erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("orig_erp_sts_cd", resultRow.erp_sts_cd$)
        
        attPtsRecordsMapOut!.put(resultRow.id, attPtsWorkDataMap!)
        
    wend        
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------------------------------------
REM  Save a single record's data stored in attPtsWorkDataMap!
REM  ------------------------------------------------------------------------------------------
    
save_record_from_map:

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$
    
    call "DateUtilities.bbj::get_current_timestamp", lastModTimeStamp$
    loginUser$ = info(3,2) 

    sqlexec(attendPtsWorkDatesChannel) attPtsWorkDataMap!.get("disp_cd"), attPtsWorkDataMap!.get("disp_edt_reas_id"),
:       attPtsWorkDataMap!.get("erp_cd"), attPtsWorkDataMap!.get("erp_note"), attPtsWorkDataMap!.get("erp_pts_assessed"),
:       attPtsWorkDataMap!.get("erp_sts_cd"), lastModTimeStamp$, loginUser$, attPtsWorkDataMap!.get("id")  

    sqlclose(attendPtsWorkDatesChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Update posted fields: timestamp, by user, WFMR exception def id
REM  ------------------------------------------------------------------------------------------
    
update_posted_flag_on_record:

        call "DateUtilities.bbj::get_current_timestamp", currentTimestamp$
        sqlexec(flagPostingChannelIn) currentTimestamp$, userIdIn$, wfmrExceptionDefIdIn, recordIdIn

    return
REM /**
REM  * AttendPtsWorkDAO.bbj
REM  * @author stevett
REM  * Written July 2015
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap
use java.util.Vector

declare java.util.LinkedHashMap datesMapOut!
declare java.util.HashMap dateQtysMap!

declare java.util.LinkedHashMap employeesMapOut!
declare java.util.HashMap employeeDataMap!

declare java.util.LinkedHashMap attPtsRecordsMapOut!
declare java.util.HashMap attPtsWorkDataMap!

declare java.util.Vector attPtsWorkIds!


rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:

def fnIsMassLoadingExceptions(aDoIt)
    return massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
fnend


def fnGetLoginUser$(aDoIt)
    tmpUser$ = info(3, 2)
    
    if len(tmpUser$) > 10 then tmpUser$ = tmpUser$(1,10)
    
    return tmpUser$
fnend


rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


mass_load_wfmr_data:

    REM  Business dates are in format like this: "2015-07-15"

    enter businessDateFromIn$, businessDateToIn$
    
    gosub setup_constants
    
    loginUser$ = fnGetLoginUser$(TRUE)
    
    massLoadSrc$ = MASS_LOAD_EXCEPTIONS_SRC$
    gosub run_mass_load
    
    massLoadSrc$ = MASS_LOAD_MISSED_SHIFT_SRC$
    gosub run_mass_load
    
    exit


get_dates_with_totals:

    enter shiftIn$, deptIdIn, payPeriodsBackIn, datesMapOut!
    
    gosub setup_constants
    
    gosub load_dates_map
    
    exit


get_employees_for_date:

    enter shiftIn$, deptIdIn, dateIn!, employeesMapOut!
    
    gosub setup_constants
    
    gosub load_employees_map
    
    exit


get_records_by_ids_in_list:

    enter attPtsWorkIds!, attPtsRecordsMapOut!
    
    gosub setup_constants
    
    gosub load_work_records_map
    
    exit


save_one_record:

    enter attPtsWorkDataMap!
    
    gosub setup_constants
    
    gosub save_record_from_map
    
    exit
    

rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------
REM  run_mass_load
REM  ------------------------------------------------------------

run_mass_load:

    gosub ml_init
    gosub ml_open_sql_channels
    gosub ml_prepare_sql_stmts
    gosub ml_process_wfmr_data
    gosub ml_close_sql_channels

    return


REM  ------------------------------------------------------------
REM  setup_constants
REM  ------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0
    
    ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$ = "current.attend.pts.policy.code"
    
    MASS_LOAD_EXCEPTIONS_SRC$ = "E"
    MASS_LOAD_MISSED_SHIFT_SRC$ = "M"
    
    PRINT_TRACE_INFO = TRUE
    BATCH_SIZE = 500
    
    DEFAULT_DISPOSITION_CODE$ = "N"
    DEFAULT_DISPOSITION_EDIT_REASON_ID = 0
    DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ = ""
    DEFAULT_LAST_MANUALLY_MODIFIED_USER$ = ""
    DEFAULT_POSTED_TIMESTAMP$ = ""
    DEFAULT_POSTED_USER$ = ""
    
    REM Uses the data source names in the SQL.INI file
    
    attendPtsDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$
    
    wfmrDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "wfmr.data.source.name", configVarFound, configVarDataType$, wfmrDataSource$
    
    attendPtsPolicyCode$ = ""
    call "ConfigVarsDAO.bbj::get_value", ATTEND_PTS_POLICY_CODE_CONFIG_VAR_NAME$, configVarFound, configVarDataType$, attendPtsPolicyCode$

    call "AttendPtsTransDAO.bbj::get_exception_ids_as_csv", attendPtsPolicyCode$, exceptionIdsAsCSV$

    
    REM  Break up field list into 5 fields per row (so readable)
       
    STARTING_INSERT_STMT$ =
:        "insert into ATTEND_PTS_WORK " +
:        "(id, wfmr_src, wfmr_exc_id, wfmr_in_tm_miss, bus_unit_id, " +
:        "dept_id, shift, emp_id, emp_badge_no, job_id, " +
:        "wfmr_exc_date, wfmr_exc_def_id, wfmr_pts_assess, wfmr_exc_lastmod, disp_cd, " +
:        "disp_edt_reas_id, erp_cd, erp_note, erp_pts_assessed, erp_sts_cd, " +
:        "last_mod, last_mod_user, posted_timestamp, posted_by_user) " +
:        "values "


    REM  Probably could have parameterized the following query with ?

    WFMR_EXCEPTIONS_SELECT_STMT$ = 
:       "select " +
:        "Lab_Exception.exception_id, " +
:        "Lab_Exception.business_unit_id, " +
:        "Lab_Job.department_id, " +
:        "Lab_Employee_Attribute.attribute_code as shift, " +
:        "Lab_Exception.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Exception.job_id, " +
:        "convert(varchar(8), Lab_Exception.business_date, 112) as exception_date, " +
:        "Lab_Exception.exception_definition_id, " +
:        "Lab_Exception_Definition.name as exception_descr, " +
:        "convert(varchar(19), Lab_Exception.last_modified_timestamp, 120) as exception_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name " +
:        "from Lab_Exception " + 
:        "inner join Lab_Exception_Definition on Lab_Exception.exception_definition_id = Lab_Exception_Definition.exception_definition_id " + 
:        "inner join Rad_Sys_User on Lab_Exception.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Exception.employee_id = Employee.employee_id " + 
:        "inner join Lab_Punch_Shift on Lab_Exception.shift_start_punch_id = Lab_Punch_Shift.shift_start_punch_id " +
:        "inner join Lab_Job on Lab_Exception.job_id = Lab_Job.job_id " + 
:        "inner join Lab_Employee_Attribute_List on Lab_Exception.employee_id = Lab_Employee_Attribute_List.employee_id " +
:        "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id " +
:        "where Lab_Exception.business_date between '" +
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ +
:        "' and Lab_Employee_Attribute_List.end_date is null " +
:        "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) " +
:        "and Lab_Exception.exception_definition_id in("+
:        exceptionIdsAsCSV$ +
:        ") " +
:        "order by exception_date, shift, last_name, first_name "
    
    
    REM  VERY IMPORTANT: Do not use apostrophes around ? symbols -- even for character fields
    
    ATTEND_PTS_EXCEPTIONS_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ?"
    
    ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set dept_id = ?, shift = ?, emp_id = ?, emp_badge_no = ?, job_id = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
:        "where wfmr_src = 'E' and wfmr_exc_id = ? and wfmr_exc_lastmod < ?"


    REM  Probably could have parameterized the following query with ?

    WFMR_MISSED_SHIFT_SELECT_STMT$ = 
:       "select " +
:       "convert(varchar(19), Lab_Employee_Missed_Shifts.in_timestamp, 120) as in_timestamp, " +
:        "Lab_Employee_Missed_Shifts.business_unit_id, " +
:        "Lab_Job.department_id, " +
:        "Lab_Employee_Attribute.attribute_code as shift, " +
:        "Lab_Employee_Missed_Shifts.employee_id, " +
:        "Employee.badge_number, " +
:        "Lab_Employee_Missed_Shifts.job_id, " +
:        "convert(varchar(8), Lab_Employee_Missed_Shifts.business_date, 112) as missed_shift_date, " +
:        "Lab_Employee_Missed_Shifts.type_code, " +
:        "convert(varchar(19), Lab_Employee_Missed_Shifts.last_modified_timestamp, 120) as missed_shift_last_mod, " +
:        "Rad_Sys_User.last_name, " + 
:        "Rad_Sys_User.first_name " +
:        "from Lab_Employee_Missed_Shifts " +
:        "inner join Rad_Sys_User on Lab_Employee_Missed_Shifts.employee_id = Rad_Sys_User.user_id " + 
:        "inner join Employee on Lab_Employee_Missed_Shifts.employee_id = Employee.employee_id " +
:        "inner join Lab_Job on Lab_Employee_Missed_Shifts.job_id = Lab_Job.job_id " + 
:        "inner join Lab_Employee_Attribute_List on Lab_Employee_Missed_Shifts.employee_id = Lab_Employee_Attribute_List.employee_id " +
:        "inner join Lab_Employee_Attribute on Lab_Employee_Attribute_List.employee_attribute_id = Lab_Employee_Attribute.employee_attribute_id " +
:        "where " + 
:        "Lab_Employee_Missed_Shifts.business_date between '" + 
:        businessDateFromIn$ +
:        "' and '" +
:        businessDateToIn$ +
:        "' and Lab_Employee_Attribute_List.end_date is null " +
:        "and Lab_Employee_Attribute_List.employee_attribute_id in (select Lab_Employee_Attribute.employee_attribute_id from Lab_Employee_Attribute where Lab_Employee_Attribute.attribute_code in ('1','2','3')) " +
:        "and Lab_Employee_Missed_Shifts.type_code in('c','n') " +
:       "order by missed_shift_date, shift, last_name, first_name"


    ATTEND_PTS_MISSED_SHIFT_FIND_STMT$ = 
:        "select count(*) as hit_count from attend_pts_work " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ?"

    ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$ = 
:        "update attend_pts_work " + 
:        "set dept_id = ?, shift = ?, emp_badge_no = ?, " + 
:        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
:        "where wfmr_src = 'M' and emp_id = ? and bus_unit_id = ? and job_id = ? and wfmr_in_tm_miss = ? " +
:        "and wfmr_exc_lastmod < ?"

    PAY_PERIODS_SELECT_STMT$ = 
:       "select distinct convert(varchar(8), start_date, 112) as pay_yyyymmdd from lab_pay_period " +
:       "where start_date < getdate() " +
:       "order by pay_yyyymmdd desc"

    ATTEND_PTS_WORK_GET_TOTALS_STMT$ = 
:       "select wfmr_exc_date, count(*) as total " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and shift = ? " +
:       "group by wfmr_exc_date " +
:       "order by wfmr_exc_date desc"

    ATTEND_PTS_WORK_GET_POSTED_STMT$ = 
:       "select wfmr_exc_date, posted_timestamp, count(*) as posted_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and shift = ? " +
:       "group by wfmr_exc_date, posted_timestamp"

    ATTEND_PTS_WORK_GET_DISPOSITION_STMT$ = 
:       "select wfmr_exc_date, disp_cd, count(*) as disp_count " +
:       "from attend_pts_work " + 
:       "where dept_id = ? and wfmr_exc_date >= ? and shift = ? " +
:       "group by wfmr_exc_date, disp_cd"

    ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$ = 
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.WFMR_EXC_DEF_ID, " +
:       "attend_pts_work.WFMR_PTS_ASSESS, " +
:       "attend_pts_work.POSTED_TIMESTAMP, " +
:       "attend_pts_work.WFMR_EXC_LASTMOD, " +
:       "attend_pts_work.ERP_CD, " +
:       "attend_pts_work.ERP_PTS_ASSESSED, " +
:       "attend_pts_work.ERP_NOTE " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "where " + 
:       "attend_pts_work.dept_id = ? and attend_pts_work.wfmr_exc_date = ? and attend_pts_work.shift = ? " +
:       "order by last_first_mi"

    ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$ = 
:       "update attend_pts_work " +
:       "set disp_cd = ?, disp_edt_reas_id = ?, erp_cd = ?, erp_note = ?, erp_pts_assessed = ?, " +
:       "erp_sts_cd = ?, last_mod = ?, last_mod_user = ? " +
:       "where id = ?"

    return

REM  ------------------------------------------------------------
REM  ml_init -- Mass Load Init
REM  ------------------------------------------------------------

ml_init:

    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$
    
    if fnIsMassLoadingExceptions(TRUE) then
        wfmrSelectStmt$ = WFMR_EXCEPTIONS_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_EXCEPTIONS_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$
    else
        wfmrSelectStmt$ = WFMR_MISSED_SHIFT_SELECT_STMT$
        attendPtsFindStmt$ = ATTEND_PTS_MISSED_SHIFT_FIND_STMT$
        attendPtsUpdateStmt$ = ATTEND_PTS_MISSED_SHIFT_UPDATE_STMT$
    endif
    
    totalInserted = 0
    
    readCount = 0
    insertCount = 0
    batchNo = 0

    return


REM  ------------------------------------------------------------
REM  ml_open_sql_channels -- Mass Load Open SQL Channels
REM  ------------------------------------------------------------

ml_open_sql_channels:

    attendPtsFindRowChannel = sqlunt
    sqlopen(attendPtsFindRowChannel) attendPtsDataSource$
    
    attendPtsInsertRowsChannel = sqlunt
    sqlopen(attendPtsInsertRowsChannel) attendPtsDataSource$
    
    attendPtsUpdateRowChannel = sqlunt
    sqlopen(attendPtsUpdateRowChannel) attendPtsDataSource$
    
    wfmrSelectRowsChannel = sqlunt
    sqlopen(wfmrSelectRowsChannel) wfmrDataSource$
    
    return; rem 1


REM  ------------------------------------------------------------
REM  ml_prepare_sql_stmts -- Mass Load Prepare SQL Statements
REM  ------------------------------------------------------------

ml_prepare_sql_stmts:

    sqlprep(attendPtsFindRowChannel) attendPtsFindStmt$
    sqlprep(attendPtsUpdateRowChannel) attendPtsUpdateStmt$
    sqlprep(wfmrSelectRowsChannel) wfmrSelectStmt$

    return; rem 2


REM  ------------------------------------------------------------
REM  ml_process_wfmr_data -- Mass Load Process WFMR Data
REM  ------------------------------------------------------------

ml_process_wfmr_data:

    sqlexec(wfmrSelectRowsChannel)
    
    dim wfmrResultRow$:sqltmpl(wfmrSelectRowsChannel)
    
    while TRUE

        REM  "while", "repeat" and "for" use same stack as gosub, so requires exitto.  "break" may work.  For BBj, *break on err= works.
    
        wfmrResultRow$ = sqlfetch(wfmrSelectRowsChannel,err=*break)
        
        readCount = readCount + 1
        
        REM  Only print details for the first record fetch
        
        if readCount > 1 then goto skip_print
        
        hits = 0
        
        if fnIsMassLoadingExceptions(TRUE) then
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.exception_id
        else
            tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
            sqlexec(attendPtsFindRowChannel) wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$ 
        endif
        
        dim ptsResultRow$:sqltmpl(attendPtsFindRowChannel)
        ptsResultRow$ = sqlfetch(attendPtsFindRowChannel,err=hit_check_bombed)
        hits = ptsResultRow$.hit_count
        hit_check_bombed:
        
        if !(fnIsMassLoadingExceptions(TRUE)) then
            if wfmrResultRow.type_code$ = "n" then 
                derived_exception_id = 11
                else 
                if wfmrResultRow.type_code$ = "c" then derived_exception_id = 46
            endif
        endif
 
        
        if PRINT_TRACE_INFO then
            if fnIsMassLoadingExceptions(TRUE) then 
                print "exception_id = ", wfmrResultRow.exception_id
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "exception_date = ", wfmrResultRow.exception_date$
                print "exception_definition_id = ", wfmrResultRow.exception_definition_id
                print "exception_descr = ", wfmrResultRow.exception_descr$
                print "exception_last_mod = ", wfmrResultRow.exception_last_mod$
                print "hits = ", hits
                print $0A$
            else
                print "in_timestamp = ", wfmrResultRow.in_timestamp$
                print "business_unit_id = ", wfmrResultRow.business_unit_id
                print "department_id = ", wfmrResultRow.department_id
                print "shift = ", wfmrResultRow.shift$
                print "employee_id = ", wfmrResultRow.employee_id
                print "badge_number = ", wfmrResultRow.badge_number$
                print "job_id = ", wfmrResultRow.job_id
                print "missed_shift_date = ", wfmrResultRow.missed_shift_date$
                print "derived_exception_id = ", derived_exception_id
                print "missed_shift_last_mod = ", wfmrResultRow.missed_shift_last_mod$
                print "hits = ", hits
                print $0A$
            endif
        endif
        
        skip_print:
        
        if hits = 0 then
           gosub ml_add_to_insert_batch
        else
           gosub ml_update_row
        endif
        
    wend

    return; rem 3
    

REM  ------------------------------------------------------------
REM  ml_update_row -- Mass Load Update a Row
REM  ------------------------------------------------------------

ml_update_row:
    
    REM  IMPORTANT: Was getting error 77 SQL before I added "cvs" to trim trailing blanks -- due to field being too long.

REM     ATTEND_PTS_EXCEPTIONS_UPDATE_STMT$ = 
REM :        "update attend_pts_work " + 
REM :        "set dept_id = ?, shift = ?, emp_id = ?, emp_badge_no = ?, job_id = ?, " + 
REM :        "wfmr_exc_date = ?, wfmr_exc_def_id = ?, wfmr_pts_assess = ?, wfmr_exc_lastmod = ? " +
REM :        "where wfmr_src = 'E' and wfmr_exc_id = ? and wfmr_exc_lastmod < ?"
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel) 
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), wfmrResultRow.employee_id, cvs(wfmrResultRow.badge_number$, 2), wfmrResultRow.job_id,
:           wfmrResultRow.exception_date$, wfmrResultRow.exception_definition_id, str(erpPts), tempLastModDate$,
:           wfmrResultRow.exception_id, tempLastModDate$
    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        tempLastModDate$ = wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) 
        tempInTimeStamp$ = wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) 
    
        sqlexec(attendPtsUpdateRowChannel) 
:           wfmrResultRow.department_id, cvs(wfmrResultRow.shift$, 2), cvs(wfmrResultRow.badge_number$, 2),
:           wfmrResultRow.missed_shift_date$, derived_exception_id, str(erpPts), tempLastModDate$,
:           wfmrResultRow.employee_id, wfmrResultRow.business_unit_id, wfmrResultRow.job_id, tempInTimeStamp$,
:           tempLastModDate$  
    endif

    return; rem 4
    

REM  ------------------------------------------------------------
REM  ml_add_to_insert_batch -- Mass Load Add a values phrase to an Insert Statement
REM  ------------------------------------------------------------

ml_add_to_insert_batch:

    insertCount = insertCount + 1
    
    if insertCount > 1 then attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + ","
    
    if fnIsMassLoadingExceptions(TRUE) then
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, wfmrResultRow.exception_definition_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'E', " +
:          str(wfmrResultRow.exception_id) + ", " +
:          "0, " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.exception_date$ + "', " +
:          str(wfmrResultRow.exception_definition_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.exception_last_mod$(1,4) + wfmrResultRow.exception_last_mod$(6,2) + wfmrResultRow.exception_last_mod$(9,2) + wfmrResultRow.exception_last_mod$(12,2) + wfmrResultRow.exception_last_mod$(15,2) + wfmrResultRow.exception_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "')"

    else
    
        call "AttendPtsTransDAO.bbj::get_erp_values", attendPtsPolicyCode$, derived_exception_id, 
:           transDataRecordFound, erpCode$, erpSts$, erpPts, erpNote$
    
        valuesClause$ =
:          "(ATTEND_PTS_WORK_SEQ.nextval, " +
:          "'M', " +
:          "0, " +
:          "'" + wfmrResultRow.in_timestamp$(1,4) + wfmrResultRow.in_timestamp$(6,2) + wfmrResultRow.in_timestamp$(9,2) + wfmrResultRow.in_timestamp$(12,2) + wfmrResultRow.in_timestamp$(15,2) + wfmrResultRow.in_timestamp$(18,2) + "', " +
:          str(wfmrResultRow.business_unit_id) + ", " +
:          str(wfmrResultRow.department_id) + ", " +
:          "'" + cvs(wfmrResultRow.shift$,2) + "', " +
:          str(wfmrResultRow.employee_id) + ", " +
:          "'" + cvs(wfmrResultRow.badge_number$, 2) + "', " +
:          str(wfmrResultRow.job_id) + ", " +
:          "'" + wfmrResultRow.missed_shift_date$ + "', " +
:          str(derived_exception_id) + ", " +
:          str(erpPts) + ", " +
:          "'" + wfmrResultRow.missed_shift_last_mod$(1,4) + wfmrResultRow.missed_shift_last_mod$(6,2) + wfmrResultRow.missed_shift_last_mod$(9,2) + wfmrResultRow.missed_shift_last_mod$(12,2) + wfmrResultRow.missed_shift_last_mod$(15,2) + wfmrResultRow.missed_shift_last_mod$(18,2) + "', " +
:          "'" + DEFAULT_DISPOSITION_CODE$ + "', " +
:          str(DEFAULT_DISPOSITION_EDIT_REASON_ID) + ", " +
:          "'" + erpCode$ + "', " +
:          "'" + erpNote$ + "', " +
:          str(erpPts) + ", " +
:          "'" + erpSts$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_LAST_MANUALLY_MODIFIED_USER$ + "', " +
:          "'" + DEFAULT_POSTED_TIMESTAMP$ + "', " +
:          "'" + DEFAULT_POSTED_USER$ + "')"
    endif
    
    attendPtsDynamicInsertStmt$ = attendPtsDynamicInsertStmt$ + valuesClause$ 

    if insertCount = BATCH_SIZE then gosub ml_write_batch

    return; rem 5


REM  ------------------------------------------------------------
REM  ml_write_batch -- Mass Load Write the Insert Batch
REM  ------------------------------------------------------------

ml_write_batch:

    batchNo = batchNo + 1
    
    print "batchNo = ", batchNo

    sqlprep(attendPtsInsertRowsChannel) attendPtsDynamicInsertStmt$
    sqlexec(attendPtsInsertRowsChannel)
    
    totalInserted = totalInserted + insertCount
    
    insertCount = 0
    
    attendPtsDynamicInsertStmt$ = STARTING_INSERT_STMT$

    return; rem 6


REM  ------------------------------------------------------------
REM  ml_close_sql_channels -- Mass Load Close SQL Channels
REM  ------------------------------------------------------------

ml_close_sql_channels:

    sqlclose(wfmrSelectRowsChannel)
    
    if insertCount > 0 then gosub ml_write_batch
    
    sqlclose(attendPtsFindRowChannel)
    sqlclose(attendPtsInsertRowsChannel)
    sqlclose(attendPtsUpdateRowChannel)

    return; rem 7    


REM  ------------------------------------------------------------
REM  load_dates_map -- Load one set of info per work file date into the datesMapOut!
REM  ------------------------------------------------------------
    
load_dates_map:
    
    datesMapOut!.clear()
    
    REM  Step 1.  Calculate the "from date" to be used to query the ATTEND_PTS_WORK file. The default will be today.

    payPeriodsChannel = sqlunt
    sqlopen(payPeriodsChannel) wfmrDataSource$
    
    sqlprep(payPeriodsChannel) PAY_PERIODS_SELECT_STMT$

    sqlexec(payPeriodsChannel) 
    dim resultRow$:sqltmpl(payPeriodsChannel)
    
    fromDate = num( date(0:"%Y%Mz%Dz") )
    
    payPeriods = 0
    
    while TRUE
    
        resultRow$ = sqlfetch(payPeriodsChannel,err=*break)
        payPeriods = payPeriods + 1
        fromDate = num(resultRow.pay_yyyymmdd$)
        
        if payPeriods >= payPeriodsBackIn then break
        
    wend
    
    sqlclose(payPeriodsChannel)
    
    
    REM  Step 2. Query the ATTEND_PTS_WORK file: populate totals
    
    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_TOTALS_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDate, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        dateQtysMap! = new java.util.HashMap()
        dateQtysMap!.put("total", resultRow.total)
        dateQtysMap!.put("posted", 0)
        
        REM  In following, key is disposition code:
        dateQtysMap!.put("A", 0)
        dateQtysMap!.put("E", 0)
        dateQtysMap!.put("F", 0)
        dateQtysMap!.put("N", 0)

        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend

    
    REM  Step 3. Query the ATTEND_PTS_WORK file: populate posted/not posted
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_POSTED_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDate, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        if !(cvs(resultRow.posted_timestamp$, 3) = "") then
            dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
            posted = dateQtysMap!.get("posted")
            posted = posted + resultRow.posted_count
            dateQtysMap!.put("posted", posted)
            datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        endif
        
    wend

    
    REM  Step 4. Query the ATTEND_PTS_WORK file: populate disposition status
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_DISPOSITION_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, fromDate, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        
        dateQtysMap! = cast( java.util.HashMap, datesMapOut!.get(resultRow.wfmr_exc_date$) )
        
        tmpTotal = dateQtysMap!.get(resultRow.disp_cd$)
        tmpTotal = tmpTotal + resultRow.disp_count
        dateQtysMap!.put(resultRow.disp_cd$, tmpTotal)
        datesMapOut!.put(resultRow.wfmr_exc_date$, dateQtysMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)


    return


REM  ------------------------------------------------------------
REM  load_employees_map -- For one date, Load a set of info per employee into the employeesMapOut!
REM  ------------------------------------------------------------
    
load_employees_map:

    employeesMapOut!.clear()

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_GET_EMPLOYEES_STMT$

    sqlexec(attendPtsWorkDatesChannel) deptIdIn, dateIn!, shiftIn$ 
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        employeeDataMap! = new java.util.HashMap()
        employeeDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        employeeDataMap!.put("disp_cd", resultRow.disp_cd$)
        employeeDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        employeeDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        employeeDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        employeeDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        employeeDataMap!.put("erp_cd", resultRow.erp_cd$)
        employeeDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        employeeDataMap!.put("erp_note", resultRow.erp_note$)

        employeesMapOut!.put(resultRow.id, employeeDataMap!)
        
    wend
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------
REM  load_work_records_map -- For each id in list, load a set of info into the attPtsRecordsMapOut!
REM  ------------------------------------------------------------
    
load_work_records_map:

    attPtsRecordsMapOut!.clear()
    
    REM  Build CSV list of ids from incoming vector:
    
    inClause$ = ""
    
    idCount = attPtsWorkIds!.size()
    
    for i = 0 to idCount - 1
    
        if i > 0 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + str( attPtsWorkIds!.get(i) ) 
         
    next i
    
    REM  Unfortunately, you can't use a single ? parm in a prepared query for a list of ids

    attendPtsWorkGetRecordsByIdListStmt$ =
:       "select " +
:       "attend_pts_work.id, " +
:       "rtrim(substring(employ.name, 14, 14)) + ', ' + rtrim(substring(employ.name, 1, 11)) + ' ' + rtrim(substring(employ.name, 12, 2)) as last_first_mi, " +
:       "attend_pts_work.job_id, " +
:       "attend_pts_work.wfmr_exc_def_id, " +
:       "attend_pts_work.wfmr_pts_assess, " +
:       "attend_pts_work.wfmr_exc_lastmod, " +
:       "attend_pts_work.disp_cd, " +
:       "attend_pts_work.disp_edt_reas_id, " +
:       "attend_pts_reasn.descr as edt_reas_descr, " +
:       "attend_pts_work.erp_cd, " +
:       "attend_pts_work.erp_note, " +
:       "attend_pts_work.erp_pts_assessed, " +
:       "attend_pts_work.erp_sts_cd, " +
:       "attend_pts_work.last_mod, " +
:       "attend_pts_work.last_mod_user, " +
:       "attend_pts_work.posted_timestamp, " +
:       "attend_pts_work.posted_by_user " +
:       "from attend_pts_work " +
:       "inner join employ on employ.badg = attend_pts_work.EMP_BADGE_NO " +
:       "left join attend_pts_reasn on attend_pts_reasn.id = attend_pts_work.disp_edt_reas_id " +
:       "where id in(" +
:       inClause$ +
:       ")"

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    
    sqlprep(attendPtsWorkDatesChannel) attendPtsWorkGetRecordsByIdListStmt$
    

    sqlexec(attendPtsWorkDatesChannel)  
    dim resultRow$:sqltmpl(attendPtsWorkDatesChannel)

    while TRUE
    
        resultRow$ = sqlfetch(attendPtsWorkDatesChannel,err=*break)
        attPtsWorkDataMap! = new java.util.HashMap()
        
        attPtsWorkDataMap!.put("id", resultRow.id)
        attPtsWorkDataMap!.put("last_first_mi", resultRow.last_first_mi$)
        attPtsWorkDataMap!.put("job_id", resultRow.job_id)
        attPtsWorkDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        attPtsWorkDataMap!.put("wfmr_pts_assess", resultRow.wfmr_pts_assess)
        attPtsWorkDataMap!.put("wfmr_exc_lastmod", resultRow.wfmr_exc_lastmod$)
        attPtsWorkDataMap!.put("disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("edt_reas_descr", resultRow.edt_reas_descr$)
        attPtsWorkDataMap!.put("erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("erp_sts_cd", resultRow.erp_sts_cd$)
        attPtsWorkDataMap!.put("last_mod", resultRow.last_mod$)
        attPtsWorkDataMap!.put("last_mod_user", resultRow.last_mod_user$)
        attPtsWorkDataMap!.put("posted_timestamp", resultRow.posted_timestamp$)
        attPtsWorkDataMap!.put("posted_by_user", resultRow.posted_by_user$)
        
        REM  Save original values of editable ERP fields:

        attPtsWorkDataMap!.put("orig_disp_cd", resultRow.disp_cd$)
        attPtsWorkDataMap!.put("orig_disp_edt_reas_id", resultRow.disp_edt_reas_id)
        attPtsWorkDataMap!.put("orig_erp_cd", resultRow.erp_cd$)
        attPtsWorkDataMap!.put("orig_erp_note", resultRow.erp_note$)
        attPtsWorkDataMap!.put("orig_erp_pts_assessed", resultRow.erp_pts_assessed)
        attPtsWorkDataMap!.put("orig_erp_sts_cd", resultRow.erp_sts_cd$)
        
        attPtsRecordsMapOut!.put(resultRow.id, attPtsWorkDataMap!)
        
    wend        
    
    sqlclose(attendPtsWorkDatesChannel)

    return


REM  ------------------------------------------------------------
REM  save_record_from_map -- Save a single record's data stored in attPtsWorkDataMap!
REM  ------------------------------------------------------------
    
save_record_from_map:

    attendPtsWorkDatesChannel = sqlunt
    sqlopen(attendPtsWorkDatesChannel) attendPtsDataSource$
    sqlprep(attendPtsWorkDatesChannel) ATTEND_PTS_WORK_SAVE_ONE_RECORD_STMT$
    
    lastModTimeStamp$ = ""
    call "DateUtilities.bbj::get_current_timestamp", lastModTimeStamp$
    
    loginUser$ = info(3,2) 

    sqlexec(attendPtsWorkDatesChannel) attPtsWorkDataMap!.get("disp_cd"), attPtsWorkDataMap!.get("disp_edt_reas_id"),
:       attPtsWorkDataMap!.get("erp_cd"), attPtsWorkDataMap!.get("erp_note"), attPtsWorkDataMap!.get("erp_pts_assessed"),
:       attPtsWorkDataMap!.get("erp_sts_cd"), lastModTimeStamp$, loginUser$, attPtsWorkDataMap!.get("id")  

    sqlclose(attendPtsWorkDatesChannel)

    return
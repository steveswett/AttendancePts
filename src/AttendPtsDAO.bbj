REM /**
REM  * AttendPtsDAO.bbj
REM  * @author stevett
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap
use java.util.Vector

declare java.util.LinkedHashMap attPtsWorkRecordsToPostMap!
declare java.util.HashMap attPtsWorkDataMap!
declare java.util.HashMap postingStatsMap!
declare java.util.HashMap qtysInsertedMap!
declare java.util.HashMap qtysUpdatedMap!

declare java.util.LinkedHashMap levelDefsMap!

declare java.util.LinkedHashMap employeeThresholdRecords!
declare java.util.LinkedHashMap employeeThresholdRecordsBefore!
declare java.util.LinkedHashMap employeeThresholdRecordsAfter!
declare java.util.HashMap thresholdDataMap!

declare java.util.LinkedHashMap thresholdChangesMap!
declare java.util.HashMap thresholdChangeDetailsMap!

declare java.util.Vector inactivatedPtsRecordsList!

declare java.util.LinkedHashMap pointRecordsMap!
declare java.util.HashMap pointDataMap!



rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:



rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


post_work_records:

    enter attPtsWorkRecordsToPostMap!, postingStatsMap!
    
    gosub setup_constants
    
    gosub post_work_records_map
    
    exit


get_current_pts_level_for_employees:

    enter employeeThresholdRecords!
    
    gosub setup_constants
    
    gosub load_thresholds_map
    
    exit
    
    
inactivate_pts_older_than_12_months:

    enter doActualUpdateIn, inactivatedPtsRecordsList!
    
    gosub setup_constants
    
    gosub inactivate_old_points
    
    exit
    
    
get_pts_records_for_employee:

    enter badge5In$, showZeroPtRecordsIn, pointRecordsMap!
    
    gosub setup_constants
    
    gosub load_point_records_map
    
    exit
    
    
get_pts_total_for_employee:

    enter badge5In$, ptsTotal
    
    gosub setup_constants
    
    gosub get_points_total
    
    exit
    


rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------
REM  setup_constants
REM  ------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0

    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$

    call "ConfigVarsDAO.bbj::get_value", "wfmr.data.source.name", configVarFound, configVarDataType$, wfmrDataSource$

    call "ConfigVarsDAO.bbj::get_value", "mail.recipients.attend.pts.warning.levels", configVarFound, configVarDataType$, warningLevelsRecipients$
    
    call "ConfigVarsDAO.bbj::get_value", "use.windows.mailsend", configVarFound, configVarDataType$, useWindowsMailSend$
    useWindowsMailSend = num(useWindowsMailSend$)

    
    POSTING_CHECK_EXIST_STMT$ = "select count(*) as hit_count from atnd where badg = ? and ptdt = ?"
    
    POSTING_UPDATE_STMT$ = 
:       "update atnd " +
:       "set pts = ?, cd = ?, stat = ?, text = ?, chgdt = ?, chgby = ?, " +
:       "work_file_id = ?, wfmr_exc_def_id = ?, wfmr_reason_id = ?, disp_cd = ? " +
:       "where badg = ? and ptdt = ?"
    
    POSTING_INSERT_STMT$ = 
:       "insert into atnd " +
:       "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, wfmr_reason_id, disp_cd) " +
:       "values " +
:       "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    GET_DATE_12_MONTHS_AGO_STMT$ = "select convert(varchar(10), dateadd(month, -12, getdate()), 120) as year_ago_date"
    
    PTS_TO_BE_INACTIVATED_STMT$ = 
:       "select employ.badg, employ.name, ptdt, pts " +
:       "from atnd " +
:       "inner join employ on employ.badg = substring(atnd.badg,2,5) " +
:       "where atnd.PTDT <= ? and atnd.STAT = 'A' and employ.termdt = '' " +
:       "order by employ.name, ptdt"

    SET_TO_INACTIVATED_STMT$ =
:       "update atnd " +
:       "set " +
:       "stat = 'I', " +
:       "text = trim(text) + ' - auto inactivated', " +
:       "chgdt = ?, " +
:       "chgby = 'cpu       ' " +
:       "where atnd.PTDT <= ? and atnd.STAT = 'A' "

    GET_NON_ZERO_PT_RECORDS_STMT$ =
:       "select badg, ptdt, pts, stat, cd, wfmr_exc_def_id, disp_cd, chgby, text " +
:       "from atnd " +
:       "where badg = ? and stat = 'A' and pts > 0 " +
:       "order by ptdt"

    GET_ALL_PT_RECORDS_STMT$ =
:       "select badg, ptdt, pts, stat, cd, wfmr_exc_def_id, disp_cd, chgby, text " +
:       "from atnd " +
:       "where badg = ?" +
:       "order by ptdt"

    GET_PTS_TOTAL_STMT$ =
:       "select sum(pts) as pts_total " +
:       "from atnd " +
:       "where badg = ? and stat = 'A'"
    
    return


REM  ------------------------------------------------------------
REM  Post the data in attPtsWorkRecordsToPostMap! and return stats
REM  ------------------------------------------------------------

post_work_records_map:

    postingStatsMap!.clear()
    qtysInsertedMap! = new java.util.HashMap() 
    qtysUpdatedMap! = new java.util.HashMap()
    
    qtysInsertedMap!.put("A", 0)
    qtysInsertedMap!.put("E", 0)
    qtysInsertedMap!.put("F", 0)
    qtysUpdatedMap!.put("A", 0)
    qtysUpdatedMap!.put("E", 0)
    qtysUpdatedMap!.put("F", 0)
    qtySaved! = 0
    qtyPosted! = 0
    
    gosub get_current_point_levels 
    employeeThresholdRecordsBefore! = new java.util.LinkedHashMap(employeeThresholdRecords!)
    
    postingCheckExistChannel = sqlunt
    sqlopen(postingCheckExistChannel) attendPtsDataSource$
    
    postingUpdateChannel = sqlunt
    sqlopen(postingUpdateChannel) attendPtsDataSource$
    
    postingInsertChannel = sqlunt
    sqlopen(postingInsertChannel) attendPtsDataSource$

    sqlprep(postingCheckExistChannel) POSTING_CHECK_EXIST_STMT$
    sqlprep(postingUpdateChannel) POSTING_UPDATE_STMT$
    sqlprep(postingInsertChannel) POSTING_INSERT_STMT$
    
    flagPostingChannel = 0
    call "AttendPtsWorkDAO.bbj::open_and_prep_channel_to_flag_posting", flagPostingChannel
    
    loginUser$ = ""
    call "TerminalUtilities.bbj::get_login_user", loginUser$ 
    
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        qtySaved! = qtySaved! + 1  

        REM  Determine whether to do insert or update
        
        doUpdate = FALSE
    
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        pointsDate$ = attPtsWorkDataMap!.get("wfmr_exc_date")

        sqlexec(postingCheckExistChannel) paddedBadge$, pointsDate$
        dim resultRow$:sqltmpl(postingCheckExistChannel)
        resultRow$ = sqlfetch(postingCheckExistChannel,err=end_check_exist)
        if resultRow.hit_count > 0 then doUpdate = TRUE
        
        end_check_exist:
        
        lastModTimestamp$ = attPtsWorkDataMap!.get("last_mod")
        lastModDateMDY$ = lastModTimestamp$(5,2) + "/" + lastModTimestamp$(7,2) + "/" + lastModTimestamp$(3,2)
        lastModByUserUC$ = cvs(attPtsWorkDataMap!.get("last_mod_user"), 4)
        wfmrExceptionDefId = attPtsWorkDataMap!.get("wfmr_exc_def_id")
        wfmrReasonId = attPtsWorkDataMap!.get("wfmr_reason_id")
             
        if doUpdate then
        
            sqlexec(postingUpdateChannel) 
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               lastModByUserUC$,
:               tmpId, 
:               wfmrExceptionDefId, 
:               wfmrReasonId, 
:               dispCode$, 
:               paddedBadge$,
:               pointsDate$

            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysUpdatedMap!.get(dispCode$) + 1
            qtysUpdatedMap!.put(dispCode$, qty!)
            
        else
        
            sqlexec(postingInsertChannel)
:               paddedBadge$,
:               pointsDate$,
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               "",        
:               lastModByUserUC$,
:               "",
:               "",
:               idKey!,        
:               wfmrExceptionDefId, 
:               wfmrReasonId, 
:               dispCode$ 
        
            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysInsertedMap!.get(dispCode$) + 1
            qtysInsertedMap!.put(dispCode$, qty!)

        endif
        
    wend
    
    sqlclose(postingCheckExistChannel)
    sqlclose(postingUpdateChannel)
    sqlclose(postingInsertChannel)

    call "AttendPtsWorkDAO.bbj::close_channel_to_flag_posting", flagPostingChannel
    
    
    gosub get_current_point_levels 
    employeeThresholdRecordsAfter! = new java.util.LinkedHashMap(employeeThresholdRecords!) 
    
    REM  Prepare threshold changes data to send back in stats:
    
    thresholdChangesMap! = new java.util.LinkedHashMap()
    
    qtyChangedWarningLevels! = 0
    iter! = employeeThresholdRecordsBefore!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        beforeThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsBefore!.get(badgeKey!) )
        afterThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsAfter!.get(badgeKey!) )

        beforeThreshold = num(beforeThresholdDataMap!.get("threshold"))
        afterThreshold = num(afterThresholdDataMap!.get("threshold"))

        if afterThreshold > beforeThreshold then
            qtyChangedWarningLevels! = qtyChangedWarningLevels! + 1
            thresholdChangeDetailsMap! = new java.util.HashMap()
            thresholdChangeDetailsMap!.put("prev_threshold", beforeThreshold)
            thresholdChangeDetailsMap!.put("new_threshold", afterThreshold)
            thresholdChangeDetailsMap!.put("last_first_mi", afterThresholdDataMap!.get("last_first_mi"))
            thresholdChangeDetailsMap!.put("total_pts", afterThresholdDataMap!.get("total_pts"))
            thresholdChangesMap!.put(badgeKey!, thresholdChangeDetailsMap!)
        endif

    wend

    postingStatsMap!.put("qtys_inserted_map", qtysInsertedMap!)
    postingStatsMap!.put("qtys_updated_map", qtysUpdatedMap!)
    postingStatsMap!.put("qty_saved", qtySaved!)
    postingStatsMap!.put("qty_posted", qtyPosted!)
    postingStatsMap!.put("qty_changed_warning_levels", qtyChangedWarningLevels!)
    postingStatsMap!.put("threshold_changes_map", thresholdChangesMap!)
    
    if qtyChangedWarningLevels! > 0 then
    
        subject$ = "Employee(s) reached a new attendance pts warning level just now"

        lineFeed$ = iff(useWindowsMailSend, "<br/>", $0A$)

        REM  Start formatting the e-mail body.
        
        body$ = ""
        
        iter! = thresholdChangesMap!.keySet().iterator()
    
        while iter!.hasNext()
        
            badgeKey! = iter!.next()
            thresholdChangeDetailsMap! = cast( java.util.HashMap, thresholdChangesMap!.get(badgeKey!) )
            
            body$ = body$ + thresholdChangeDetailsMap!.get("last_first_mi") + " reached level " +
:               str( thresholdChangeDetailsMap!.get("new_threshold") ) + ".  Previously at level " +
:               str( thresholdChangeDetailsMap!.get("prev_threshold") ) + ".  Total current points is " +
:               str( thresholdChangeDetailsMap!.get("total_pts") ) + "." + lineFeed$ + lineFeed$
            
        wend
        
        body$ = body$ + lineFeed$ + "Generated from Attendance Points Supervisor Approval program (" +
:           pgm(-2) + ") by user " + loginUser$ + "."

        REM  Finish formatting the e-mail body.
    
        call "MailUtilities.bbj::send_simple_email_msg", warningLevelsRecipients$, subject$, body$
    
    endif
    
    return


    rem ------------------------------------------------------------------------------------------
    rem  Get current point levels for employees with saved records
    rem ------------------------------------------------------------------------------------------


get_current_point_levels:

    employeeThresholdRecords! = new java.util.LinkedHashMap()
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        
        thresholdDataMap! = new java.util.HashMap()
        thresholdDataMap!.put("threshold", 0)
        thresholdDataMap!.put("total_pts", 0)
        thresholdDataMap!.put("last_first_mi", cvs(attPtsWorkDataMap!.get("last_first_mi"), 2) )
        
        employeeThresholdRecords!.put(paddedBadge$, thresholdDataMap!)
        
    wend

    gosub load_thresholds_map

    return

    
REM  ------------------------------------------------------------
REM  Load each employee's current points level (threshold) into employeeThresholdRecords!
REM  ------------------------------------------------------------

load_thresholds_map:

    REM  Step 1. Build a list of badge numbers of inClause$
    
    inClause$ = ""
    count = 0
    iter! = employeeThresholdRecords!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        count = count + 1
        if count > 1 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + "'" + badgeKey! + "'"
      
    wend

    
    REM  Step 2. Construct a union query using each level definition

    levelDefsMap! = new java.util.LinkedHashMap()
    call "AttendPtsLevDAO.bbj::get_thresholds_and_descrs", levelDefsMap!
    
    unionSql$ = ""
    count = 0
    iter! = levelDefsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        thresholdKey! = iter!.next()
        thresholdValue = thresholdKey!
        count = count + 1
        if count > 1 then unionSql$ = unionSql$ + "union "
        
        unionSql$ = unionSql$ + "select badg, sum(pts) as total_pts, " + str(thresholdValue) +
:           " as threshold " +
:           "from atnd where badg in(" + inClause$ + ") and stat = 'A' group by badg " +
:           "having sum(pts) >= " +  str(thresholdValue) + " "
      
    wend
    
    unionSql$ = unionSql$ + "order by badg, threshold desc"
    
    
    REM  Step 3. Run query and load results
    
    thresholdsChannel = sqlunt
    sqlopen(thresholdsChannel) attendPtsDataSource$

    sqlprep(thresholdsChannel) unionSql$
    sqlexec(thresholdsChannel) 
    dim resultRow$:sqltmpl(thresholdsChannel)

    REM  An employee may qualify for multiple levels.  For example, if he has 7.5 points, he'll qualify
    REM  for 4 and 6.  Only load the first (highest) -- 6, for example.
    
    prevBadge$ = ""
    
    while TRUE
    
        resultRow$ = sqlfetch(thresholdsChannel,err=*break)
        currentBadge$ = resultRow.badg$
        
        if !(currentBadge$ = prevBadge$) then

            thresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecords!.get(currentBadge$) )
            thresholdDataMap!.put("threshold", resultRow.threshold)
            thresholdDataMap!.put("total_pts", resultRow.total_pts)

        endif
        
        prevBadge$ = currentBadge$
        
    wend
    
    sqlclose(thresholdsChannel)
    
    return

    
REM  ------------------------------------------------------------
REM  Inactivate points older than 12 months (from today)
REM  ------------------------------------------------------------
    
    
inactivate_old_points:

    inactivatedPtsRecordsList!.clear()

    REM  Step 1. Compute date 12 months ago (using SQL Server for leap year handling)
    
    sqlServerChannel = sqlunt
    sqlopen(sqlServerChannel) wfmrDataSource$
    
    sqlprep(sqlServerChannel) GET_DATE_12_MONTHS_AGO_STMT$
    sqlexec(sqlServerChannel)
     
    dim resultRow$:sqltmpl(sqlServerChannel)
    resultRow$ = sqlfetch(sqlServerChannel,err=failed_year_ago_fetch)
    yearAgoDate$ = resultRow.year_ago_date$
    
    REM  Step 2. Query to get list of employees who qualify to have pts inactivated
    
    cutOffDate$ = yearAgoDate$(1,4) + yearAgoDate$(6,2) + yearAgoDate$(9,2)
     
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    sqlprep(attendPtsChannel) PTS_TO_BE_INACTIVATED_STMT$
    sqlexec(attendPtsChannel) cutOffDate$

    dim resultRow$:sqltmpl(attendPtsChannel)

    while TRUE
        resultRow$ = sqlfetch(attendPtsChannel,err=*break)
        call "DateUtilities.bbj::get_yymd_as_mdyy_with_slashes", resultRow.ptdt$, TRUE, fmtPtsDate$ 
        outputRecord$ = resultRow.badg$ + ",""" + resultRow.name$ + """," + fmtPtsDate$ + "," + str(resultRow.pts)
        inactivatedPtsRecordsList!.add(outputRecord$) 
    wend
    
    
    REM  Step 3. Run the update query to inactivate the points
    
    if doActualUpdateIn then
        sqlprep(attendPtsChannel) SET_TO_INACTIVATED_STMT$
        sqlexec(attendPtsChannel) day, cutOffDate$
    endif
    
    sqlclose(attendPtsChannel)
    
    failed_year_ago_fetch:
    
    sqlclose(sqlServerChannel)
    
    return
    
    
REM  ------------------------------------------------------------
REM  Load point records for a single employee
REM  ------------------------------------------------------------
    
    
load_point_records_map:

    pointRecordsMap!.clear()
    
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    if showZeroPtRecordsIn then
        sqlprep(attendPtsChannel) GET_ALL_PT_RECORDS_STMT$
    else
        sqlprep(attendPtsChannel) GET_NON_ZERO_PT_RECORDS_STMT$
    endif

    badge6$ = "0" + badge5In$
    sqlexec(attendPtsChannel) badge6$ 
    dim resultRow$:sqltmpl(attendPtsChannel)
    
    runningTotal = 0
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsChannel,err=*break)
        pointDataMap! = new java.util.HashMap()
        pointDataMap!.put("pts", resultRow.pts)
        pointDataMap!.put("stat", resultRow.stat$)
        pointDataMap!.put("cd", resultRow.cd$)
        pointDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        pointDataMap!.put("disp_cd", resultRow.disp_cd$)
        pointDataMap!.put("chgby", resultRow.chgby$)
        
        if resultRow.stat$ = "A" then
            runningTotal = runningTotal + resultRow.pts
        endif

        pointDataMap!.put("running_total", runningTotal)
        
        fullText$ = cvs(resultRow.text$,2)
        textLength = len(fullText$)
        text1$ = ""
        text2$ = ""
        text3$ = ""
        
        if textLength > 100 then
            text1$ = fullText$(1,50)
            text2$ = fullText$(51,50)
            text3$ = fullText$(101)
        endif
        
        if textLength > 50 and textLength <= 100 then
            text1$ = fullText$(1,50)
            text2$ = fullText$(51)
        endif
        
        if textLength > 0 and textLength <= 50 then
            text1$ = fullText$(1)
        endif

        pointDataMap!.put("text1", text1$)
        pointDataMap!.put("text2", text2$)
        pointDataMap!.put("text3", text3$)

        pointRecordsMap!.put(resultRow.ptdt$, pointDataMap!)
        
    wend
    
    sqlclose(attendPtsChannel)

    return
    
    
REM  ------------------------------------------------------------
REM  Get total active points for a single employee
REM  ------------------------------------------------------------
    
    
get_points_total:

    ptsTotal = 0
    
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    sqlprep(attendPtsChannel) GET_PTS_TOTAL_STMT$

    badge6$ = "0" + badge5In$
    sqlexec(attendPtsChannel) badge6$ 
    dim resultRow$:sqltmpl(attendPtsChannel)
    
    resultRow$ = sqlfetch(attendPtsChannel,err=total_not_found)
    
    ptsTotal = resultRow.pts_total
    
    total_not_found:
    
    sqlclose(attendPtsChannel)

    return
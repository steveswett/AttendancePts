REM /**
REM  * AttendPtsDAO.bbj
REM  * @author stevett
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap

declare java.util.LinkedHashMap attPtsWorkRecordsToPostMap!
declare java.util.HashMap attPtsWorkDataMap!
declare java.util.HashMap postingStatsMap!
declare java.util.HashMap qtysInsertedMap!
declare java.util.HashMap qtysUpdatedMap!

declare java.util.LinkedHashMap levelDefsMap!

declare java.util.LinkedHashMap employeeThresholds!
declare java.util.LinkedHashMap employeeThresholdsBefore!
declare java.util.LinkedHashMap employeeThresholdsAfter!

declare java.util.LinkedHashMap thresholdChangesMap!
declare java.util.HashMap thresholdChangeDetailsMap!



rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:



rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


post_work_records:

    enter attPtsWorkRecordsToPostMap!, postingStatsMap!
    
    gosub setup_constants
    
    gosub post_work_records_map
    
    exit


get_current_pts_level_for_employees:

    enter employeeThresholds!
    
    gosub setup_constants
    
    gosub load_thresholds_map
    
    exit


rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------
REM  setup_constants
REM  ------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0

    attendPtsDataSource$ = ""
    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$
    
    POSTING_CHECK_EXIST_STMT$ = "select count(*) as hit_count from atnd where work_file_id = ?"
    
    POSTING_UPDATE_STMT$ = 
:       "update atnd " +
:       "set pts = ?, cd = ?, stat = ?, text = ?, chgdt = ?, chgby = ?, " +
:       "wfmr_exc_def_id = ?, disp_cd = ? " +
:       "where work_file_id = ?"
    
    POSTING_INSERT_STMT$ = 
:       "insert into atnd " +
:       "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, disp_cd) " +
:       "values " +
:       "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    
    return


REM  ------------------------------------------------------------
REM  Post the data in attPtsWorkRecordsToPostMap! and return stats
REM  ------------------------------------------------------------

post_work_records_map:

    postingStatsMap!.clear()
    qtysInsertedMap! = new java.util.HashMap() 
    qtysUpdatedMap! = new java.util.HashMap()
    
    qtysInsertedMap!.put("A", 0)
    qtysInsertedMap!.put("E", 0)
    qtysInsertedMap!.put("F", 0)
    qtysUpdatedMap!.put("A", 0)
    qtysUpdatedMap!.put("E", 0)
    qtysUpdatedMap!.put("F", 0)
    qtySaved! = 0
    qtyPosted! = 0
    
    gosub get_current_point_levels 
    employeeThresholdsBefore! = new java.util.LinkedHashMap(employeeThresholds!)
    
    print @(0,22), 'CL', "before threshold = ", employeeThresholdsBefore!.get("032942")
    input @(70,22), "(hit enter)", ignoreInput$ 

    postingCheckExistChannel = sqlunt
    sqlopen(postingCheckExistChannel) attendPtsDataSource$
    
    postingUpdateChannel = sqlunt
    sqlopen(postingUpdateChannel) attendPtsDataSource$
    
    postingInsertChannel = sqlunt
    sqlopen(postingInsertChannel) attendPtsDataSource$

    sqlprep(postingCheckExistChannel) POSTING_CHECK_EXIST_STMT$
    sqlprep(postingUpdateChannel) POSTING_UPDATE_STMT$
    sqlprep(postingInsertChannel) POSTING_INSERT_STMT$
    
    flagPostingChannel = 0
    call "AttendPtsWorkDAO.bbj::open_and_prep_channel_to_flag_posting", flagPostingChannel
    
    loginUser$ = ""
    call "TerminalUtilities.bbj::get_login_user", loginUser$ 
    
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        qtySaved! = qtySaved! + 1  

        REM  Determine whether to do insert or update
        
        doUpdate = FALSE
    
        sqlexec(postingCheckExistChannel) idKey!
        dim resultRow$:sqltmpl(postingCheckExistChannel)
        resultRow$ = sqlfetch(postingCheckExistChannel,err=end_check_exist)
        if resultRow.hit_count > 0 then doUpdate = TRUE
        
        end_check_exist:
        
        lastModTimestamp$ = attPtsWorkDataMap!.get("last_mod")
        lastModDateMDY$ = lastModTimestamp$(5,2) + "/" + lastModTimestamp$(7,2) + "/" + lastModTimestamp$(3,2)
        lastModByUserUC$ = cvs(attPtsWorkDataMap!.get("last_mod_user"), 4)
        wfmrExceptionDefId = attPtsWorkDataMap!.get("wfmr_exc_def_id")
             
        if doUpdate then
        
            sqlexec(postingUpdateChannel) 
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               lastModByUserUC$,
:               wfmrExceptionDefId, 
:               dispCode$, 
:               idKey!

            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysUpdatedMap!.get(dispCode$) + 1
            qtysUpdatedMap!.put(dispCode$, qty!)
            
        else
        
            trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
            paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )

            sqlexec(postingInsertChannel)
:               paddedBadge$,
:               attPtsWorkDataMap!.get("wfmr_exc_date"),
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               "",        
:               lastModByUserUC$,
:               "",
:               "",
:               idKey!,        
:               wfmrExceptionDefId, 
:               dispCode$ 
        
            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysInsertedMap!.get(dispCode$) + 1
            qtysInsertedMap!.put(dispCode$, qty!)

        endif
        
    wend
    
    sqlclose(postingCheckExistChannel)
    sqlclose(postingUpdateChannel)
    sqlclose(postingInsertChannel)

    call "AttendPtsWorkDAO.bbj::close_channel_to_flag_posting", flagPostingChannel
    
    
    gosub get_current_point_levels 
    employeeThresholdsAfter! = new java.util.LinkedHashMap(employeeThresholds!) 
    
    print @(0,22), 'CL', "after threshold = ", employeeThresholdsAfter!.get("032942")
    input @(70,22), "(hit enter)", ignoreInput$ 
    
    REM  Prepare threshold changes data to send back in stats:
    
    thresholdChangesMap! = new java.util.LinkedHashMap()
    
    qtyChangedWarningLevels! = 0
    iter! = employeeThresholdsBefore!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        beforeThreshold = num(employeeThresholdsBefore!.get(badgeKey!))
        afterThreshold = num(employeeThresholdsAfter!.get(badgeKey!))

        if afterThreshold > beforeThreshold then
            qtyChangedWarningLevels! = qtyChangedWarningLevels! + 1
            thresholdChangeDetailsMap! = new java.util.HashMap()
            thresholdChangeDetailsMap!.put("prev_threshold", beforeThreshold)
            thresholdChangeDetailsMap!.put("new_threshold", afterThreshold)
            thresholdChangesMap!.put(badgeKey!, thresholdChangeDetailsMap!)
        endif

    wend

    postingStatsMap!.put("qtys_inserted_map", qtysInsertedMap!)
    postingStatsMap!.put("qtys_updated_map", qtysUpdatedMap!)
    postingStatsMap!.put("qty_saved", qtySaved!)
    postingStatsMap!.put("qty_posted", qtyPosted!)
    postingStatsMap!.put("qty_changed_warning_levels", qtyChangedWarningLevels!)
    postingStatsMap!.put("threshold_changes_map", thresholdChangesMap!)
    
    REM  TODO: This is where a process should be called to send an e-mail about threshold changes.
    REM        Keep the e-mail process as simple as possible.
    
    return


    rem ------------------------------------------------------------------------------------------
    rem  Get current point levels for employees with saved records
    rem ------------------------------------------------------------------------------------------


get_current_point_levels:

    employeeThresholds! = new java.util.LinkedHashMap()
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        
        employeeThresholds!.put(paddedBadge$, 0)
        
    wend

    gosub load_thresholds_map

    return

    
REM  ------------------------------------------------------------
REM  Load each employee's current points level (threshold) into employeeThresholds!
REM  ------------------------------------------------------------

load_thresholds_map:

    REM  Step 1. Build a list of badge numbers of inClause$
    
    inClause$ = ""
    count = 0
    iter! = employeeThresholds!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        count = count + 1
        if count > 1 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + "'" + badgeKey! + "'"
      
    wend

    
    REM  Step 2. Construct a union query using each level definition

    levelDefsMap! = new java.util.LinkedHashMap()
    call "AttendPtsLevDAO.bbj::get_thresholds_and_descrs", levelDefsMap!
    
    unionSql$ = ""
    count = 0
    iter! = levelDefsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        thresholdKey! = iter!.next()
        thresholdValue = thresholdKey!
        count = count + 1
        if count > 1 then unionSql$ = unionSql$ + "union "
        
        unionSql$ = unionSql$ + "select badg, sum(pts) as total_pts, " + str(thresholdValue) +
:           " as threshold " +
:           "from atnd where badg in(" + inClause$ + ") and stat = 'A' group by badg " +
:           "having sum(pts) >= " +  str(thresholdValue) + " "
      
    wend
    
    unionSql$ = unionSql$ + "order by badg, threshold desc"
    
    
    REM  Step 3. Run query and load results
    
    thresholdsChannel = sqlunt
    sqlopen(thresholdsChannel) attendPtsDataSource$

    sqlprep(thresholdsChannel) unionSql$
    sqlexec(thresholdsChannel) 
    dim resultRow$:sqltmpl(thresholdsChannel)

    REM  An employee may qualify for multiple levels.  For example, if he has 7.5 points, he'll qualify
    REM  for 4 and 6.  Only load the first (highest) -- 6, for example.
    
    prevBadge$ = ""
    
    while TRUE
    
        resultRow$ = sqlfetch(thresholdsChannel,err=*break)
        currentBadge$ = resultRow.badg$
        
        if !(currentBadge$ = prevBadge$) then
            employeeThresholds!.put(currentBadge$, resultRow.threshold)
        endif
        
        prevBadge$ = currentBadge$
        
    wend
    
    sqlclose(thresholdsChannel)
    
    return
    
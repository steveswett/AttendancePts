REM /**
REM  * AttendPtsDAO.bbj
REM  * @author stevett
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap

declare java.util.LinkedHashMap attPtsWorkRecordsToPostMap!
declare java.util.HashMap attPtsWorkDataMap!
declare java.util.HashMap postingStatsMap!
declare java.util.HashMap qtysInsertedMap!
declare java.util.HashMap qtysUpdatedMap!

declare java.util.LinkedHashMap levelDefsMap!

declare java.util.LinkedHashMap employeeThresholdRecords!
declare java.util.LinkedHashMap employeeThresholdRecordsBefore!
declare java.util.LinkedHashMap employeeThresholdRecordsAfter!
declare java.util.HashMap thresholdDataMap!

declare java.util.LinkedHashMap thresholdChangesMap!
declare java.util.HashMap thresholdChangeDetailsMap!



rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:



rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


post_work_records:

    enter attPtsWorkRecordsToPostMap!, postingStatsMap!
    
    gosub setup_constants
    
    gosub post_work_records_map
    
    exit


get_current_pts_level_for_employees:

    enter employeeThresholdRecords!
    
    gosub setup_constants
    
    gosub load_thresholds_map
    
    exit


rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


REM  ------------------------------------------------------------
REM  setup_constants
REM  ------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0

    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$

    call "ConfigVarsDAO.bbj::get_value", "mail.recipients.attend.pts.warning.levels", configVarFound, configVarDataType$, warningLevelsRecipients$
    
    call "ConfigVarsDAO.bbj::get_value", "use.windows.mailsend", configVarFound, configVarDataType$, useWindowsMailSend$
    useWindowsMailSend = num(useWindowsMailSend$)

    
    POSTING_CHECK_EXIST_STMT$ = "select count(*) as hit_count from atnd where work_file_id = ?"
    
    POSTING_UPDATE_STMT$ = 
:       "update atnd " +
:       "set pts = ?, cd = ?, stat = ?, text = ?, chgdt = ?, chgby = ?, " +
:       "wfmr_exc_def_id = ?, disp_cd = ? " +
:       "where work_file_id = ?"
    
    POSTING_INSERT_STMT$ = 
:       "insert into atnd " +
:       "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, disp_cd) " +
:       "values " +
:       "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    
    return


REM  ------------------------------------------------------------
REM  Post the data in attPtsWorkRecordsToPostMap! and return stats
REM  ------------------------------------------------------------

post_work_records_map:

    postingStatsMap!.clear()
    qtysInsertedMap! = new java.util.HashMap() 
    qtysUpdatedMap! = new java.util.HashMap()
    
    qtysInsertedMap!.put("A", 0)
    qtysInsertedMap!.put("E", 0)
    qtysInsertedMap!.put("F", 0)
    qtysUpdatedMap!.put("A", 0)
    qtysUpdatedMap!.put("E", 0)
    qtysUpdatedMap!.put("F", 0)
    qtySaved! = 0
    qtyPosted! = 0
    
    gosub get_current_point_levels 
    employeeThresholdRecordsBefore! = new java.util.LinkedHashMap(employeeThresholdRecords!)
    
    postingCheckExistChannel = sqlunt
    sqlopen(postingCheckExistChannel) attendPtsDataSource$
    
    postingUpdateChannel = sqlunt
    sqlopen(postingUpdateChannel) attendPtsDataSource$
    
    postingInsertChannel = sqlunt
    sqlopen(postingInsertChannel) attendPtsDataSource$

    sqlprep(postingCheckExistChannel) POSTING_CHECK_EXIST_STMT$
    sqlprep(postingUpdateChannel) POSTING_UPDATE_STMT$
    sqlprep(postingInsertChannel) POSTING_INSERT_STMT$
    
    flagPostingChannel = 0
    call "AttendPtsWorkDAO.bbj::open_and_prep_channel_to_flag_posting", flagPostingChannel
    
    loginUser$ = ""
    call "TerminalUtilities.bbj::get_login_user", loginUser$ 
    
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        qtySaved! = qtySaved! + 1  

        REM  Determine whether to do insert or update
        
        doUpdate = FALSE
    
        sqlexec(postingCheckExistChannel) idKey!
        dim resultRow$:sqltmpl(postingCheckExistChannel)
        resultRow$ = sqlfetch(postingCheckExistChannel,err=end_check_exist)
        if resultRow.hit_count > 0 then doUpdate = TRUE
        
        end_check_exist:
        
        lastModTimestamp$ = attPtsWorkDataMap!.get("last_mod")
        lastModDateMDY$ = lastModTimestamp$(5,2) + "/" + lastModTimestamp$(7,2) + "/" + lastModTimestamp$(3,2)
        lastModByUserUC$ = cvs(attPtsWorkDataMap!.get("last_mod_user"), 4)
        wfmrExceptionDefId = attPtsWorkDataMap!.get("wfmr_exc_def_id")
             
        if doUpdate then
        
            sqlexec(postingUpdateChannel) 
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               lastModByUserUC$,
:               wfmrExceptionDefId, 
:               dispCode$, 
:               idKey!

            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysUpdatedMap!.get(dispCode$) + 1
            qtysUpdatedMap!.put(dispCode$, qty!)
            
        else
        
            trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
            paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )

            sqlexec(postingInsertChannel)
:               paddedBadge$,
:               attPtsWorkDataMap!.get("wfmr_exc_date"),
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               "",        
:               lastModByUserUC$,
:               "",
:               "",
:               idKey!,        
:               wfmrExceptionDefId, 
:               dispCode$ 
        
            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysInsertedMap!.get(dispCode$) + 1
            qtysInsertedMap!.put(dispCode$, qty!)

        endif
        
    wend
    
    sqlclose(postingCheckExistChannel)
    sqlclose(postingUpdateChannel)
    sqlclose(postingInsertChannel)

    call "AttendPtsWorkDAO.bbj::close_channel_to_flag_posting", flagPostingChannel
    
    
    gosub get_current_point_levels 
    employeeThresholdRecordsAfter! = new java.util.LinkedHashMap(employeeThresholdRecords!) 
    
    REM  Prepare threshold changes data to send back in stats:
    
    thresholdChangesMap! = new java.util.LinkedHashMap()
    
    qtyChangedWarningLevels! = 0
    iter! = employeeThresholdRecordsBefore!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        beforeThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsBefore!.get(badgeKey!) )
        afterThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsAfter!.get(badgeKey!) )

        beforeThreshold = num(beforeThresholdDataMap!.get("threshold"))
        afterThreshold = num(afterThresholdDataMap!.get("threshold"))

        if afterThreshold > beforeThreshold then
            qtyChangedWarningLevels! = qtyChangedWarningLevels! + 1
            thresholdChangeDetailsMap! = new java.util.HashMap()
            thresholdChangeDetailsMap!.put("prev_threshold", beforeThreshold)
            thresholdChangeDetailsMap!.put("new_threshold", afterThreshold)
            thresholdChangeDetailsMap!.put("last_first_mi", afterThresholdDataMap!.get("last_first_mi"))
            thresholdChangeDetailsMap!.put("total_pts", afterThresholdDataMap!.get("total_pts"))
            thresholdChangesMap!.put(badgeKey!, thresholdChangeDetailsMap!)
        endif

    wend

    postingStatsMap!.put("qtys_inserted_map", qtysInsertedMap!)
    postingStatsMap!.put("qtys_updated_map", qtysUpdatedMap!)
    postingStatsMap!.put("qty_saved", qtySaved!)
    postingStatsMap!.put("qty_posted", qtyPosted!)
    postingStatsMap!.put("qty_changed_warning_levels", qtyChangedWarningLevels!)
    postingStatsMap!.put("threshold_changes_map", thresholdChangesMap!)
    
    if qtyChangedWarningLevels! > 0 then
    
        subject$ = "Employee(s) reached a new attendance pts warning level just now"

        lineFeed$ = iff(useWindowsMailSend, "<br/>", $0A$)

        REM  Start formatting the e-mail body.
        
        body$ = ""
        
        iter! = thresholdChangesMap!.keySet().iterator()
    
        while iter!.hasNext()
        
            badgeKey! = iter!.next()
            thresholdChangeDetailsMap! = cast( java.util.HashMap, thresholdChangesMap!.get(badgeKey!) )
            
            body$ = body$ + thresholdChangeDetailsMap!.get("last_first_mi") + " reached level " +
:               str( thresholdChangeDetailsMap!.get("new_threshold") ) + ".  Previously at level " +
:               str( thresholdChangeDetailsMap!.get("prev_threshold") ) + ".  Total current points is " +
:               str( thresholdChangeDetailsMap!.get("total_pts") ) + "." + lineFeed$ + lineFeed$
            
        wend
        
        body$ = body$ + lineFeed$ + "Generated from Attendance Points Supervisor Approval program (" +
:           pgm(-2) + ") by user " + loginUser$ + "."

        REM  Finish formatting the e-mail body.
    
        call "MailUtilities.bbj::send_simple_email_msg", warningLevelsRecipients$, subject$, body$
    
    endif
    
    return


    rem ------------------------------------------------------------------------------------------
    rem  Get current point levels for employees with saved records
    rem ------------------------------------------------------------------------------------------


get_current_point_levels:

    employeeThresholdRecords! = new java.util.LinkedHashMap()
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        
        thresholdDataMap! = new java.util.HashMap()
        thresholdDataMap!.put("threshold", 0)
        thresholdDataMap!.put("total_pts", 0)
        thresholdDataMap!.put("last_first_mi", cvs(attPtsWorkDataMap!.get("last_first_mi"), 2) )
        
        employeeThresholdRecords!.put(paddedBadge$, thresholdDataMap!)
        
    wend

    gosub load_thresholds_map

    return

    
REM  ------------------------------------------------------------
REM  Load each employee's current points level (threshold) into employeeThresholdRecords!
REM  ------------------------------------------------------------

load_thresholds_map:

    REM  Step 1. Build a list of badge numbers of inClause$
    
    inClause$ = ""
    count = 0
    iter! = employeeThresholdRecords!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        count = count + 1
        if count > 1 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + "'" + badgeKey! + "'"
      
    wend

    
    REM  Step 2. Construct a union query using each level definition

    levelDefsMap! = new java.util.LinkedHashMap()
    call "AttendPtsLevDAO.bbj::get_thresholds_and_descrs", levelDefsMap!
    
    unionSql$ = ""
    count = 0
    iter! = levelDefsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        thresholdKey! = iter!.next()
        thresholdValue = thresholdKey!
        count = count + 1
        if count > 1 then unionSql$ = unionSql$ + "union "
        
        unionSql$ = unionSql$ + "select badg, sum(pts) as total_pts, " + str(thresholdValue) +
:           " as threshold " +
:           "from atnd where badg in(" + inClause$ + ") and stat = 'A' group by badg " +
:           "having sum(pts) >= " +  str(thresholdValue) + " "
      
    wend
    
    unionSql$ = unionSql$ + "order by badg, threshold desc"
    
    
    REM  Step 3. Run query and load results
    
    thresholdsChannel = sqlunt
    sqlopen(thresholdsChannel) attendPtsDataSource$

    sqlprep(thresholdsChannel) unionSql$
    sqlexec(thresholdsChannel) 
    dim resultRow$:sqltmpl(thresholdsChannel)

    REM  An employee may qualify for multiple levels.  For example, if he has 7.5 points, he'll qualify
    REM  for 4 and 6.  Only load the first (highest) -- 6, for example.
    
    prevBadge$ = ""
    
    while TRUE
    
        resultRow$ = sqlfetch(thresholdsChannel,err=*break)
        currentBadge$ = resultRow.badg$
        
        if !(currentBadge$ = prevBadge$) then

            thresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecords!.get(currentBadge$) )
            thresholdDataMap!.put("threshold", resultRow.threshold)
            thresholdDataMap!.put("total_pts", resultRow.total_pts)

        endif
        
        prevBadge$ = currentBadge$
        
    wend
    
    sqlclose(thresholdsChannel)
    
    return
    
REM /**
REM  * AttendPtsDAO.bbj
REM  * @author stevett
REM  *
REM  * Written: August 2015
REM  * 
REM  * Description: Data Access Object for table ATND
REM  *
REM  */


use java.util.LinkedHashMap
use java.util.HashMap
use java.util.Vector
use java.util.HashSet

declare java.util.LinkedHashMap attPtsWorkRecordsToPostMap!
declare java.util.HashMap attPtsWorkDataMap!
declare java.util.HashMap postingStatsMap!
declare java.util.HashMap qtysInsertedMap!
declare java.util.HashMap qtysUpdatedMap!

declare java.util.LinkedHashMap levelDefsMap!

declare java.util.LinkedHashMap employeeThresholdRecords!
declare java.util.LinkedHashMap employeeThresholdRecordsBefore!
declare java.util.LinkedHashMap employeeThresholdRecordsAfter!
declare java.util.HashMap thresholdDataMap!

declare java.util.LinkedHashMap thresholdChangesMap!
declare java.util.HashMap thresholdChangeDetailsMap!

declare java.util.Vector inactivatedPtsRecordsList!

declare java.util.LinkedHashMap pointRecordsMap!
declare java.util.HashMap pointDataMap!

declare java.util.HashSet employeesWithZeroPtsSet!

declare java.util.LinkedHashMap employeeRecordsMap!
declare java.util.HashMap employeeDataMap!



rem *- - - - - - - - - - CONSTANTS - - - - - - - - - -*

rem  This section never runs for multi-entry point called programs, so subroutine "setup_constants" is called
rem  for each entry point.


rem *- - - - - - - - - - FUNCTIONS - - - - - - - - - -*

functions:



rem *- - - - - - - - - - ENTRY POINTS - - - - - - - - - -*

entry_points:


post_work_records:

    enter attPtsWorkRecordsToPostMap!, postingStatsMap!
    
    gosub setup_constants
    
    gosub post_work_records_map
    
    exit


get_current_pts_level_for_employees:

    enter employeeThresholdRecords!
    
    gosub setup_constants
    
    gosub load_thresholds_map
    
    exit
    
    
inactivate_pts_older_than_12_months:

    enter doActualUpdateIn, inactivatedPtsRecordsList!
    
    gosub setup_constants
    
    gosub inactivate_old_points
    
    exit
    
    
get_default_pt_data_map_for_add:

    enter pointDataMap!
    
    gosub setup_constants
    
    gosub load_default_point_data_map
    
    exit
    
    
get_pts_records_for_employee:

    enter badge5In$, showZeroPtRecordsIn, pointRecordsMap!
    
    gosub setup_constants
    
    gosub load_point_records_map
    
    exit
    
    
get_pts_total_for_employee:

    enter badge5In$, ptsTotal
    
    gosub setup_constants
    
    gosub get_points_total
    
    exit
    
    
get_employees_with_zero_pts_for_date_range:

    enter yyyymmddFromIn$, yyyymmddToIn$, employeesWithZeroPtsSet!
    
    gosub setup_constants
    
    gosub get_employees_with_zero_pts
    
    exit
    
    
compute_pts_for_90_day_window_for_employees:

    enter employeeRecordsMap!, yyyymmddToIn$
    
    gosub setup_constants
    
    gosub compute_and_store_90_day_pts

    exit
    
    
update_pts_record_for_employee:

    enter badge5In$, pointsDate!, pointDataMap!
    
    gosub setup_constants
    
    gosub update_pts_record
    
    exit
    
    
insert_pts_record_for_employee:

    enter badge5In$, pointsDate!, pointDataMap!
    
    gosub setup_constants
    
    gosub insert_pts_record
    
    exit
    
    
delete_pts_record_for_employee:

    enter badge5In$, pointsDate!
    
    gosub setup_constants
    
    gosub delete_pts_record
    
    exit
    
    
does_pts_record_exist:

    enter badge5In$, pointsDate$, doesPtsRecordExist
    
    gosub setup_constants
    
    gosub check_existence_of_pts_record
    
    exit
    
    
add_pts_and_next_drop_info_to_map:

    enter employeeRecordsMap!
    
    gosub setup_constants
    
    gosub append_pts_and_next_drop_date_info

    exit
    


rem *- - - - - - - - - - SUBROUTINES - - - - - - - - - -*

subroutines:


    rem ------------------------------------------------------------------------------------------
    rem  Append total points and next drop date info to an existing employeeRecordsMap!
    rem ------------------------------------------------------------------------------------------


append_pts_and_next_drop_date_info:

    REM  Step 1. Get total attendance points and put in EmployeeRecordsMap!

    call "DateUtilities.bbj::get_yyyymmdd_relative_to_today", -365, yyyymmddOneYearAgo$

    call "DateUtilities.bbj::get_current_yyyymmdd", yyyymmddToday$

    ptsChannel = sqlunt
    sqlopen(ptsChannel) attendPtsDataSource$
    sqlprep(ptsChannel) GET_PTS_TOTAL_RANGE_STMT$
    
    iter! = employeeRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        
        sqlexec(ptsChannel) "0" + badgeKey!, yyyymmddOneYearAgo$, yyyymmddToday$
        dim resultRow$:sqltmpl(ptsChannel)
        
        resultRow$ = sqlfetch(ptsChannel,err=*next)
        employeeDataMap! = cast( java.util.HashMap, employeeRecordsMap!.get(badgeKey!) )
        employeeDataMap!.put("pts_total", resultRow.pts_total)
        employeeRecordsMap!.put(badgeKey!, employeeDataMap!) 
    
    wend


    REM  Step 2. Get next drop date info and put in EmployeeRecordsMap!

    REM  For performance reasons, a date-related query is repeated here (directly) using a prepared
    REM  statement.
    
    wfmrDataChannel = sqlunt
    sqlopen(wfmrDataChannel) wfmrDataSource$
    sqlprep(wfmrDataChannel) "select convert(varchar(10), dateadd(month, 12, ?), 120) as relative_date"

    sqlprep(ptsChannel) GET_NEXT_DROP_DATE_INFO_STMT$
    
    iter! = employeeRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        
        sqlexec(ptsChannel) "0" + badgeKey!, yyyymmddOneYearAgo$
        dim resultRow$:sqltmpl(ptsChannel)
        
        resultRow$ = sqlfetch(ptsChannel,err=*next)
        
        if len(resultRow.ptdt$) = 0 then continue
        
        employeeDataMap! = cast( java.util.HashMap, employeeRecordsMap!.get(badgeKey!) )
        
        REM Actual date loaded needs to be 12 months in the future of the one found
        
        sqlFormattedDate$ = resultRow.ptdt$(1,4) + "-" + resultRow.ptdt$(5,2) + "-" + resultRow.ptdt$(7,2)
        sqlexec(wfmrDataChannel) sqlFormattedDate$

        dim resRow$:sqltmpl(wfmrDataChannel)
        resRow$ = sqlfetch(wfmrDataChannel,err=row_not_found)
        
        yyyymmddFuture$ = resRow.relative_date$(1,4) + resRow.relative_date$(6,2) + resRow.relative_date$(9,2) 

        employeeDataMap!.put("ptdt", yyyymmddFuture$)

        employeeDataMap!.put("pts", resultRow.pts)
        employeeRecordsMap!.put(badgeKey!, employeeDataMap!) 
            
        row_not_found:
    
    wend

    sqlclose(ptsChannel)
    sqlclose(wfmrDataChannel)

    return


    rem ------------------------------------------------------------------------------------------
    rem  Get current point levels for employees with saved records
    rem ------------------------------------------------------------------------------------------


get_current_point_levels:

    employeeThresholdRecords! = new java.util.LinkedHashMap()
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        
        thresholdDataMap! = new java.util.HashMap()
        thresholdDataMap!.put("threshold", 0)
        thresholdDataMap!.put("total_pts", 0)
        thresholdDataMap!.put("last_first_mi", cvs(attPtsWorkDataMap!.get("last_first_mi"), 2) )
        
        employeeThresholdRecords!.put(paddedBadge$, thresholdDataMap!)
        
    wend

    gosub load_thresholds_map

    return

    
REM  ------------------------------------------------------------------------------------------
REM  Inactivate points older than 12 months (from today)
REM  ------------------------------------------------------------------------------------------
    
    
inactivate_old_points:

    inactivatedPtsRecordsList!.clear()

    REM  Step 1. Compute date 12 months ago (using SQL Server for leap year handling)
    
    sqlServerChannel = sqlunt
    sqlopen(sqlServerChannel) wfmrDataSource$
    
    sqlprep(sqlServerChannel) GET_DATE_12_MONTHS_AGO_STMT$
    sqlexec(sqlServerChannel)
     
    dim resultRow$:sqltmpl(sqlServerChannel)
    resultRow$ = sqlfetch(sqlServerChannel,err=failed_year_ago_fetch)
    yearAgoDate$ = resultRow.year_ago_date$
    
    REM  Step 2. Query to get list of employees who qualify to have pts inactivated
    
    cutOffDate$ = yearAgoDate$(1,4) + yearAgoDate$(6,2) + yearAgoDate$(9,2)
     
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    sqlprep(attendPtsChannel) PTS_TO_BE_INACTIVATED_STMT$
    sqlexec(attendPtsChannel) cutOffDate$

    dim resultRow$:sqltmpl(attendPtsChannel)

    while TRUE
        resultRow$ = sqlfetch(attendPtsChannel,err=*break)
        call "DateUtilities.bbj::get_yymd_as_mdyy_with_slashes", resultRow.ptdt$, TRUE, fmtPtsDate$ 
        outputRecord$ = resultRow.badg$ + ",""" + resultRow.name$ + """," + fmtPtsDate$ + "," + str(resultRow.pts)
        inactivatedPtsRecordsList!.add(outputRecord$) 
    wend
    
    
    REM  Step 3. Run the update query to inactivate the points
    
    if doActualUpdateIn then
        sqlprep(attendPtsChannel) SET_TO_INACTIVATED_STMT$
        sqlexec(attendPtsChannel) day, cutOffDate$
    endif
    
    sqlclose(attendPtsChannel)
    
    failed_year_ago_fetch:
    
    sqlclose(sqlServerChannel)
    
    return

    
REM  ------------------------------------------------------------------------------------------
REM  Load default point data map for a single record add/insert
REM  ------------------------------------------------------------------------------------------
    
    
load_default_point_data_map:

    pointDataMap!.clear()
    
    call "DateUtilities.bbj::get_current_timestamp", tmpDate$

    pointDataMap!.put("ptdt", tmpDate$(1,8))
    pointDataMap!.put("pts", 0)
    pointDataMap!.put("stat", " ")
    pointDataMap!.put("cd", " ")
    pointDataMap!.put("wfmr_exc_def_id", 0)
    pointDataMap!.put("wfmr_reason_id", 0)
    pointDataMap!.put("disp_cd", "")
    pointDataMap!.put("adddt", day)
    pointDataMap!.put("chgdt", "")
    
    ucLoginUser$ = cvs(info(3,2), 4)
    
    pointDataMap!.put("addby", ucLoginUser$)
    pointDataMap!.put("chgby", "")
    pointDataMap!.put("running_total", 0)
    
    pointDataMap!.put("text1", "")
    pointDataMap!.put("text2", "")
    pointDataMap!.put("text3", "")
    
    pointDataMap!.put("pts_removal_date", "")
    pointDataMap!.put("pts_removed", "")

    return
    
REM  ------------------------------------------------------------------------------------------
REM  Load point records for a single employee
REM  ------------------------------------------------------------------------------------------
    
    
load_point_records_map:

    pointRecordsMap!.clear()
    
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    if showZeroPtRecordsIn then
        sqlprep(attendPtsChannel) GET_ALL_PT_RECORDS_STMT$
    else
        sqlprep(attendPtsChannel) GET_NON_ZERO_PT_RECORDS_STMT$
    endif

    badge6$ = "0" + badge5In$
    sqlexec(attendPtsChannel) badge6$ 
    dim resultRow$:sqltmpl(attendPtsChannel)
    
    runningTotal = 0
    
    while TRUE
    
        resultRow$ = sqlfetch(attendPtsChannel,err=*break)
        pointDataMap! = new java.util.HashMap()
        pointDataMap!.put("pts", resultRow.pts)
        pointDataMap!.put("stat", resultRow.stat$)
        pointDataMap!.put("cd", resultRow.cd$)
        pointDataMap!.put("wfmr_exc_def_id", resultRow.wfmr_exc_def_id)
        pointDataMap!.put("wfmr_reason_id", resultRow.wfmr_reason_id)
        pointDataMap!.put("disp_cd", resultRow.disp_cd$)
        pointDataMap!.put("adddt", resultRow.adddt$)
        pointDataMap!.put("chgdt", resultRow.chgdt$)
        pointDataMap!.put("addby", resultRow.addby$)
        pointDataMap!.put("chgby", resultRow.chgby$)
        
        if resultRow.stat$ = "A" then
            runningTotal = runningTotal + resultRow.pts
        endif

        pointDataMap!.put("running_total", runningTotal)
        
        fullText$ = cvs(resultRow.text$,2)
        textLength = len(fullText$)
        text1$ = ""
        text2$ = ""
        text3$ = ""
        
        if textLength > 100 then
            text1$ = fullText$(1,50)
            text2$ = fullText$(51,50)
            text3$ = fullText$(101)
        endif
        
        if textLength > 50 and textLength <= 100 then
            text1$ = fullText$(1,50)
            text2$ = fullText$(51)
        endif
        
        if textLength > 0 and textLength <= 50 then
            text1$ = fullText$(1)
        endif

        pointDataMap!.put("text1", text1$)
        pointDataMap!.put("text2", text2$)
        pointDataMap!.put("text3", text3$)
        
        REM  Deduce the pts removal date:
        ptsRemovalDate$ = ""
        ptsRemoved$ = ""
        
        for t = 3 to 1 STEP -1
        
            switch t
                
                case 1
                    textToSearch$ = cvs(text1$, 2)
                    break
                
                case 2
                    textToSearch$ = cvs(text2$, 2)
                    break
                
                case 3
                    textToSearch$ = cvs(text3$, 2)
                    break
                     
            swend

            if len(textToSearch$) = 0 then continue
            
            needToBreak = FALSE

            for i = 1 to NO_OF_PTS_REMOVAL_PHRASES
            
                searchFor$ = PTS_REMOVAL_PHRASES_ARRAY$[i] 
                foundAt = pos(searchFor$=textToSearch$, -1)
                
                if foundAt > 0 then
                    
                    rem print "textToSearch$ = ", textToSearch$
                    stringToTheRight$ = textToSearch$(foundAt + len(searchFor$))
                    rem print "stringToTheRight$ = ", stringToTheRight$
                    firstDateSlashAt = pos("/"=stringToTheRight$, 1, 1)
                    secondDateSlashAt = pos("/"=stringToTheRight$, 1, 2)
                    
                    if firstDateSlashAt > 0 and secondDateSlashAt > 0 then
                        endOfDatePos = secondDateSlashAt + 2 
    
                        if firstDateSlashAt = 2 then
                            begOfDatePos = 1
                        endif
                        
                        if firstDateSlashAt > 2 then
                            begOfDatePos = firstDateSlashAt - 2
                        endif
                        
                        dateLength = endOfDatePos - begOfDatePos + 1
                        ptsRemovalDate$ = " " + stringToTheRight$(begOfDatePos, dateLength)
                        
                        REM print "ptsRemovalDate$ = ", ptsRemovalDate$
                        
                        REM  PTS_QTY_PHRASES_ARRAY$
                        
                        for r = 1 to NO_OF_PTS_QTY_PHRASES

                          searchForPhrase$ = PTS_QTY_PHRASES_ARRAY$[r] 
                          hitAt = pos(searchForPhrase$=textToSearch$)
                          
                          if hitAt > 0 then
                                ptsRemoved$ = textToSearch$( 1, hitAt + len(searchForPhrase$) - 2 )
                          endif

                        next r

    
                        needToBreak = TRUE    
                        break
    
                    endif 
                    
                endif
                
            next i
            
            if needToBreak then break
        
        next t
        
        rem print "points date, pts removal date = ", resultRow.ptdt$, ptsRemovalDate$ 
        pointDataMap!.put("pts_removal_date", ptsRemovalDate$)
        pointDataMap!.put("pts_removed", ptsRemoved$)

        pointRecordsMap!.put(resultRow.ptdt$, pointDataMap!)
        
    wend
    
    sqlclose(attendPtsChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Get total active points for a single employee
REM  ------------------------------------------------------------------------------------------
    
    
get_points_total:

    ptsTotal = 0
    
    attendPtsChannel = sqlunt
    sqlopen(attendPtsChannel) attendPtsDataSource$
    
    sqlprep(attendPtsChannel) GET_PTS_TOTAL_STMT$

    badge6$ = "0" + badge5In$
    sqlexec(attendPtsChannel) badge6$ 
    dim resultRow$:sqltmpl(attendPtsChannel)
    
    resultRow$ = sqlfetch(attendPtsChannel,err=total_not_found)
    
    ptsTotal = resultRow.pts_total
    
    total_not_found:
    
    sqlclose(attendPtsChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  For a given date range, get employees with zero pts and put in employeesWithZeroPtsSet! 
REM  ------------------------------------------------------------------------------------------


get_employees_with_zero_pts:

    employeesWithZeroPtsSet!.clear()
    
    zeroPtsChannel = sqlunt
    sqlopen(zeroPtsChannel) attendPtsDataSource$

    sqlprep(zeroPtsChannel) GET_ZERO_PTS_FOR_DATE_RANGE_STMT$
    sqlexec(zeroPtsChannel) yyyymmddFromIn$, yyyymmddToIn$
    dim resultRow$:sqltmpl(zeroPtsChannel)
    
    while TRUE
        resultRow$ = sqlfetch(zeroPtsChannel,err=*break)
        employeesWithZeroPtsSet!.add(cvs(resultRow.badg$, 2))
    wend
    
    sqlclose(zeroPtsChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Load each employee's current points level (threshold) into employeeThresholdRecords!
REM  ------------------------------------------------------------------------------------------

load_thresholds_map:

    REM  Step 1. Build a list of badge numbers of inClause$
    
    inClause$ = ""
    count = 0
    iter! = employeeThresholdRecords!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        count = count + 1
        if count > 1 then inClause$ = inClause$ + ","
        inClause$ = inClause$ + "'" + badgeKey! + "'"
      
    wend

    
    REM  Step 2. Construct a union query using each level definition

    levelDefsMap! = new java.util.LinkedHashMap()
    call "AttendPtsLevDAO.bbj::get_thresholds_and_descrs", levelDefsMap!
    
    unionSql$ = ""
    count = 0
    iter! = levelDefsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        thresholdKey! = iter!.next()
        thresholdValue = thresholdKey!
        count = count + 1
        if count > 1 then unionSql$ = unionSql$ + "union "
        
        unionSql$ = unionSql$ + "select badg, sum(pts) as total_pts, " + str(thresholdValue) +
:           " as threshold " +
:           "from atnd where badg in(" + inClause$ + ") and stat = 'A' group by badg " +
:           "having sum(pts) >= " +  str(thresholdValue) + " "
      
    wend
    
    unionSql$ = unionSql$ + "order by badg, threshold desc"
    
    
    REM  Step 3. Run query and load results
    
    thresholdsChannel = sqlunt
    sqlopen(thresholdsChannel) attendPtsDataSource$

    sqlprep(thresholdsChannel) unionSql$
    sqlexec(thresholdsChannel) 
    dim resultRow$:sqltmpl(thresholdsChannel)

    REM  An employee may qualify for multiple levels.  For example, if he has 7.5 points, he'll qualify
    REM  for 4 and 6.  Only load the first (highest) -- 6, for example.
    
    prevBadge$ = ""
    
    while TRUE
    
        resultRow$ = sqlfetch(thresholdsChannel,err=*break)
        currentBadge$ = resultRow.badg$
        
        if !(currentBadge$ = prevBadge$) then

            thresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecords!.get(currentBadge$) )
            thresholdDataMap!.put("threshold", resultRow.threshold)
            thresholdDataMap!.put("total_pts", resultRow.total_pts)

        endif
        
        prevBadge$ = currentBadge$
        
    wend
    
    sqlclose(thresholdsChannel)
    
    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Update one record for one employee, using pointDataMap! for input
REM  ------------------------------------------------------------------------------------------


update_pts_record:

    updateChannel = sqlunt
    sqlopen(updateChannel) attendPtsDataSource$
    
    sqlprep(updateChannel) UPDATE_SINGLE_PTS_RECORD_STMT$

    fullText$ = 
:   pad( pointDataMap!.get("text1") , 50, "L", " ") + 
:   pad( pointDataMap!.get("text2") , 50, "L", " ") + 
:   pointDataMap!.get("text3")

    ucLoginUser$ = cvs(info(3,2), 4)

    badge6$ = "0" + badge5In$
    
REM     print @(0,21), 'CL', 
REM     print @(0,22), 'CL', "pointDataMap!.get(""pts"") = ", pointDataMap!.get("pts")
REM     input @(60,22), "hit any key", ignoreInput$

    sqlexec(updateChannel) pointDataMap!.get("pts"), pointDataMap!.get("stat"), pointDataMap!.get("cd"),
:       fullText$, day, ucLoginUser$, pointDataMap!.get("disp_cd"), badge6$, pointsDate!

    sqlclose(updateChannel)
    
    call "EmployeeMasterDAO.bbj::set_attend_pts_date_to_today", badge5In$ 

    return
 
    
REM  ------------------------------------------------------------------------------------------
REM  Delete an attendance points record
REM  ------------------------------------------------------------------------------------------

    
delete_pts_record:

    deleteChannel = sqlunt
    sqlopen(deleteChannel) attendPtsDataSource$
    
    sqlprep(deleteChannel) DELETE_SINGLE_PTS_RECORD_STMT$

    badge6$ = "0" + badge5In$

    sqlexec(deleteChannel) badge6$, pointsDate!

    sqlclose(deleteChannel)
    
    call "EmployeeMasterDAO.bbj::set_attend_pts_date_to_today", badge5In$ 

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Check to see whether attendance points record exists
REM  ------------------------------------------------------------------------------------------

    
check_existence_of_pts_record:

    doesPtsRecordExist = FALSE
    
    existenceChannel = sqlunt
    sqlopen(existenceChannel) attendPtsDataSource$
    
    sqlprep(existenceChannel) CHECK_EXIST_STMT$

    badge6$ = "0" + badge5In$

    sqlexec(existenceChannel) badge6$, pointsDate$
    dim resultRow$:sqltmpl(existenceChannel)
    resultRow$ = sqlfetch(existenceChannel,err=pts_record_absent)
    
    if resultRow.hit_count > 0 then doesPtsRecordExist = TRUE
    
    pts_record_absent:

    sqlclose(existenceChannel)

    return
    
    
REM  ------------------------------------------------------------------------------------------
REM  Insert one record for one employee, using pointDataMap! for input
REM  ------------------------------------------------------------------------------------------


insert_pts_record:

    insertChannel = sqlunt
    sqlopen(insertChannel) attendPtsDataSource$
    
    sqlprep(insertChannel) INSERT_SINGLE_PTS_RECORD_STMT$
    
REM     INSERT_SINGLE_PTS_RECORD_STMT$ =
REM :   "insert into atnd " +
REM :   "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, wfmr_reason_id, disp_cd) " +
REM :   "values " +
REM :   "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    fullText$ = 
:   pad( pointDataMap!.get("text1") , 50, "L", " ") + 
:   pad( pointDataMap!.get("text2") , 50, "L", " ") + 
:   pointDataMap!.get("text3")

    ucLoginUser$ = cvs(info(3,2), 4)

    badge6$ = "0" + badge5In$

    sqlexec(insertChannel) badge6$, pointsDate!, pointDataMap!.get("pts"), 
:       pointDataMap!.get("cd"), pointDataMap!.get("stat"), fullText$, 
:      day, "", ucLoginUser$, "", "", 0, 0, 0, "" 

    sqlclose(insertChannel)
    
    call "EmployeeMasterDAO.bbj::set_attend_pts_date_to_today", badge5In$ 

    return
    

REM  ------------------------------------------------------------------------------------------
REM  Post the data in attPtsWorkRecordsToPostMap! and return stats
REM  ------------------------------------------------------------------------------------------

post_work_records_map:

    postingStatsMap!.clear()
    qtysInsertedMap! = new java.util.HashMap() 
    qtysUpdatedMap! = new java.util.HashMap()
    
    qtysInsertedMap!.put("A", 0)
    qtysInsertedMap!.put("E", 0)
    qtysInsertedMap!.put("F", 0)
    qtysUpdatedMap!.put("A", 0)
    qtysUpdatedMap!.put("E", 0)
    qtysUpdatedMap!.put("F", 0)
    qtySaved! = 0
    qtyPosted! = 0
    
    gosub get_current_point_levels 
    employeeThresholdRecordsBefore! = new java.util.LinkedHashMap(employeeThresholdRecords!)
    
    postingCheckExistChannel = sqlunt
    sqlopen(postingCheckExistChannel) attendPtsDataSource$
    
    postingUpdateChannel = sqlunt
    sqlopen(postingUpdateChannel) attendPtsDataSource$
    
    postingInsertChannel = sqlunt
    sqlopen(postingInsertChannel) attendPtsDataSource$

    sqlprep(postingCheckExistChannel) CHECK_EXIST_STMT$
    sqlprep(postingUpdateChannel) POSTING_UPDATE_STMT$
    sqlprep(postingInsertChannel) POSTING_INSERT_STMT$
    
    flagPostingChannel = 0
    call "AttendPtsWorkDAO.bbj::open_and_prep_channel_to_flag_posting", flagPostingChannel
    
    loginUser$ = ""
    call "TerminalUtilities.bbj::get_login_user", loginUser$ 
    
    iter! = attPtsWorkRecordsToPostMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        idKey! = iter!.next()
        tmpId = num(idKey!)
        attPtsWorkDataMap! = cast( java.util.HashMap, attPtsWorkRecordsToPostMap!.get(idKey!) )
        dataWasSaved! = attPtsWorkDataMap!.get("saved")
        if dataWasSaved! = null() then continue
        dispCode$ = attPtsWorkDataMap!.get("disp_cd")
        if dispCode$ = "N" then continue
        
        qtySaved! = qtySaved! + 1  

        REM  Determine whether to do insert or update
        
        doUpdate = FALSE
    
        trimmedBadge$ = cvs(attPtsWorkDataMap!.get("emp_badge_no"), 3) 
        paddedBadge$ = pad(trimmedBadge$, 6, "R", "0" )
        pointsDate$ = attPtsWorkDataMap!.get("wfmr_exc_date")

        sqlexec(postingCheckExistChannel) paddedBadge$, pointsDate$
        dim resultRow$:sqltmpl(postingCheckExistChannel)
        resultRow$ = sqlfetch(postingCheckExistChannel,err=end_check_exist)
        if resultRow.hit_count > 0 then doUpdate = TRUE
        
        end_check_exist:
        
        lastModTimestamp$ = attPtsWorkDataMap!.get("last_mod")
        lastModDateMDY$ = lastModTimestamp$(5,2) + "/" + lastModTimestamp$(7,2) + "/" + lastModTimestamp$(3,2)
        lastModByUserUC$ = cvs(attPtsWorkDataMap!.get("last_mod_user"), 4)
        wfmrExceptionDefId = attPtsWorkDataMap!.get("wfmr_exc_def_id")
        wfmrReasonId = attPtsWorkDataMap!.get("wfmr_reason_id")
             
        if doUpdate then
        
            sqlexec(postingUpdateChannel) 
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               lastModByUserUC$,
:               tmpId, 
:               wfmrExceptionDefId, 
:               wfmrReasonId, 
:               dispCode$, 
:               paddedBadge$,
:               pointsDate$

            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysUpdatedMap!.get(dispCode$) + 1
            qtysUpdatedMap!.put(dispCode$, qty!)
            
        else
        
            sqlexec(postingInsertChannel)
:               paddedBadge$,
:               pointsDate$,
:               attPtsWorkDataMap!.get("erp_pts_assessed"), 
:               attPtsWorkDataMap!.get("erp_cd"),
:               attPtsWorkDataMap!.get("erp_sts_cd"),
:               attPtsWorkDataMap!.get("erp_note"), 
:               lastModDateMDY$, 
:               "",        
:               lastModByUserUC$,
:               "",
:               "",
:               idKey!,        
:               wfmrExceptionDefId, 
:               wfmrReasonId, 
:               dispCode$ 
        
            call "AttendPtsWorkDAO.bbj::flag_posting", flagPostingChannel, tmpId, loginUser$, wfmrExceptionDefId
            
            qtyPosted! = qtyPosted! + 1  
            qty! = qtysInsertedMap!.get(dispCode$) + 1
            qtysInsertedMap!.put(dispCode$, qty!)

        endif
        
    wend
    
    sqlclose(postingCheckExistChannel)
    sqlclose(postingUpdateChannel)
    sqlclose(postingInsertChannel)

    call "AttendPtsWorkDAO.bbj::close_channel_to_flag_posting", flagPostingChannel
    
    
    gosub get_current_point_levels 
    employeeThresholdRecordsAfter! = new java.util.LinkedHashMap(employeeThresholdRecords!) 
    
    REM  Prepare threshold changes data to send back in stats:
    
    thresholdChangesMap! = new java.util.LinkedHashMap()
    
    qtyChangedWarningLevels! = 0
    iter! = employeeThresholdRecordsBefore!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        beforeThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsBefore!.get(badgeKey!) )
        afterThresholdDataMap! = cast( java.util.HashMap, employeeThresholdRecordsAfter!.get(badgeKey!) )

        beforeThreshold = num(beforeThresholdDataMap!.get("threshold"))
        afterThreshold = num(afterThresholdDataMap!.get("threshold"))

        if afterThreshold > beforeThreshold then
            qtyChangedWarningLevels! = qtyChangedWarningLevels! + 1
            thresholdChangeDetailsMap! = new java.util.HashMap()
            thresholdChangeDetailsMap!.put("prev_threshold", beforeThreshold)
            thresholdChangeDetailsMap!.put("new_threshold", afterThreshold)
            thresholdChangeDetailsMap!.put("last_first_mi", afterThresholdDataMap!.get("last_first_mi"))
            thresholdChangeDetailsMap!.put("total_pts", afterThresholdDataMap!.get("total_pts"))
            thresholdChangesMap!.put(badgeKey!, thresholdChangeDetailsMap!)
        endif

    wend

    postingStatsMap!.put("qtys_inserted_map", qtysInsertedMap!)
    postingStatsMap!.put("qtys_updated_map", qtysUpdatedMap!)
    postingStatsMap!.put("qty_saved", qtySaved!)
    postingStatsMap!.put("qty_posted", qtyPosted!)
    postingStatsMap!.put("qty_changed_warning_levels", qtyChangedWarningLevels!)
    postingStatsMap!.put("threshold_changes_map", thresholdChangesMap!)
    
    if qtyChangedWarningLevels! > 0 then
    
        subject$ = "Employee(s) reached a new attendance pts warning level just now"

        lineFeed$ = iff(useWindowsMailSend, "<br/>", $0A$)

        REM  Start formatting the e-mail body.
        
        body$ = ""
        
        iter! = thresholdChangesMap!.keySet().iterator()
    
        while iter!.hasNext()
        
            badgeKey! = iter!.next()
            thresholdChangeDetailsMap! = cast( java.util.HashMap, thresholdChangesMap!.get(badgeKey!) )
            
            body$ = body$ + thresholdChangeDetailsMap!.get("last_first_mi") + " reached level " +
:               str( thresholdChangeDetailsMap!.get("new_threshold") ) + ".  Previously at level " +
:               str( thresholdChangeDetailsMap!.get("prev_threshold") ) + ".  Total current points is " +
:               str( thresholdChangeDetailsMap!.get("total_pts") ) + "." + lineFeed$ + lineFeed$
            
        wend
        
        body$ = body$ + lineFeed$ + "Generated from Attendance Points Supervisor Approval program (" +
:           pgm(-2) + ") by user " + loginUser$ + "."

        REM  Finish formatting the e-mail body.
    
        call "MailUtilities.bbj::send_simple_email_msg", warningLevelsRecipients$, subject$, body$
    
    endif
    
    return


REM  ------------------------------------------------------------------------------------------
REM  setup_constants
REM  ------------------------------------------------------------------------------------------

setup_constants:

    TRUE = 1
    FALSE = 0
    
    NO_OF_PTS_REMOVAL_PHRASES = 7
    dim PTS_REMOVAL_PHRASES_ARRAY$[1:NO_OF_PTS_REMOVAL_PHRASES]
    PTS_REMOVAL_PHRASES_ARRAY$[1] = "AWAY ON "
    PTS_REMOVAL_PHRASES_ARRAY$[2] = "REMOVED "
    PTS_REMOVAL_PHRASES_ARRAY$[3] = "INACTIVE ON "
    PTS_REMOVAL_PHRASES_ARRAY$[4] = "OFF ON "
    PTS_REMOVAL_PHRASES_ARRAY$[5] = "AWAY "
    PTS_REMOVAL_PHRASES_ARRAY$[6] = "AWAYON "; REM  Yes, this "typo" one is intended
    PTS_REMOVAL_PHRASES_ARRAY$[7] = "AWYA ON "; REM  Yes, this "typo" one is intended
    
    NO_OF_PTS_QTY_PHRASES = 4
    dim PTS_QTY_PHRASES_ARRAY$[1:NO_OF_PTS_QTY_PHRASES]
    PTS_QTY_PHRASES_ARRAY$[1] = "POINT "
    PTS_QTY_PHRASES_ARRAY$[2] = "POINTS "
    PTS_QTY_PHRASES_ARRAY$[3] = "PT "
    PTS_QTY_PHRASES_ARRAY$[4] = "PTS "

    call "ConfigVarsDAO.bbj::get_value", "new.attend.pts.files.data.source.name", configVarFound, configVarDataType$, attendPtsDataSource$

    call "ConfigVarsDAO.bbj::get_value", "wfmr.data.source.name", configVarFound, configVarDataType$, wfmrDataSource$

    call "ConfigVarsDAO.bbj::get_value", "mail.recipients.attend.pts.warning.levels", configVarFound, configVarDataType$, warningLevelsRecipients$
    
    call "ConfigVarsDAO.bbj::get_value", "use.windows.mailsend", configVarFound, configVarDataType$, useWindowsMailSend$
    useWindowsMailSend = num(useWindowsMailSend$)

    call "ConfigVarsDAO.bbj::get_value", "employ.table.ops.jobareas.where.clause", configVarFound, configVarDataType$, jobareasWhereClause$

    
    CHECK_EXIST_STMT$ = "select count(*) as hit_count from atnd where badg = ? and ptdt = ?"
    
    POSTING_UPDATE_STMT$ = 
:       "update atnd " +
:       "set pts = ?, cd = ?, stat = ?, text = ?, chgdt = ?, chgby = ?, " +
:       "work_file_id = ?, wfmr_exc_def_id = ?, wfmr_reason_id = ?, disp_cd = ? " +
:       "where badg = ? and ptdt = ?"
    
    POSTING_INSERT_STMT$ = 
:       "insert into atnd " +
:       "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, wfmr_reason_id, disp_cd) " +
:       "values " +
:       "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    GET_DATE_12_MONTHS_AGO_STMT$ = "select convert(varchar(10), dateadd(month, -12, getdate()), 120) as year_ago_date"
    
    PTS_TO_BE_INACTIVATED_STMT$ = 
:       "select employ.badg, employ.name, ptdt, pts " +
:       "from atnd " +
:       "inner join employ on employ.badg = substring(atnd.badg,2,5) " +
:       "where atnd.PTDT <= ? and atnd.STAT = 'A' and employ.termdt = '' " +
:       "order by employ.name, ptdt"

    SET_TO_INACTIVATED_STMT$ =
:       "update atnd " +
:       "set " +
:       "stat = 'I', " +
:       "text = trim(text) + ' - auto inactivated', " +
:       "chgdt = ?, " +
:       "chgby = 'cpu       ' " +
:       "where atnd.PTDT <= ? and atnd.STAT = 'A' "

    GET_NON_ZERO_PT_RECORDS_STMT$ =
:       "select badg, ptdt, pts, stat, cd, wfmr_exc_def_id, disp_cd, text, wfmr_reason_id, adddt, addby, chgdt, chgby " +
:       "from atnd " +
:       "where badg = ? and stat = 'A' and pts > 0 " +
:       "order by ptdt"

    GET_ALL_PT_RECORDS_STMT$ =
:       "select badg, ptdt, pts, stat, cd, wfmr_exc_def_id, disp_cd, text, wfmr_reason_id, adddt, addby, chgdt, chgby " +
:       "from atnd " +
:       "where badg = ?" +
:       "order by ptdt"

    GET_PTS_TOTAL_STMT$ =
:       "select sum(pts) as pts_total " +
:       "from atnd " +
:       "where badg = ? and stat = 'A'"

    UPDATE_SINGLE_PTS_RECORD_STMT$ =
:       "update atnd " +
:       "set pts = ?, stat = ?, cd = ?, text = ?, chgdt = ?, chgby = ?, disp_cd = ? " +
:       "where " +
:       "badg = ? and ptdt = ?"

    INSERT_SINGLE_PTS_RECORD_STMT$ =
:       "insert into atnd " +
:       "(badg, ptdt, pts, cd, stat, text, adddt, chgdt, addby, chgby, lvar, work_file_id, wfmr_exc_def_id, wfmr_reason_id, disp_cd) " +
:       "values " +
:       "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

    DELETE_SINGLE_PTS_RECORD_STMT$ =
:       "delete from atnd " +
:       "where " +
:       "badg = ? and ptdt = ?"

    GET_ZERO_PTS_FOR_DATE_RANGE_STMT$ =
:       "select employ.badg, sum(atnd.pts) as total_pts " +
:       "from employ " +
:       "left join atnd on '0' + employ.badg = atnd.badg and atnd.stat = 'A' and atnd.ptdt >= ? and atnd.ptdt <= ? " +
:       "where " + 
:       "employ.termdt = '' and " + 
:       "employ.salhr = 'H' and " +
:       cvs(jobareasWhereClause$, 2) + " " +
:       "group by employ.badg " +
:       "having sum(atnd.pts) = 0"

    GET_PTS_TOTAL_RANGE_STMT$ =
:       "select sum(pts) as pts_total " +
:       "from atnd " +
:       "where badg = ? and ptdt >= ? and ptdt <= ? and stat = 'A'"

    GET_NEXT_DROP_DATE_INFO_STMT$ =
:       "select top 1 ptdt, pts " + 
:       "from atnd " +
:       "where badg = ? and ptdt >= ? and stat = 'A' and pts > 0 " +
:       "order by ptdt"
    
    return


REM  ------------------------------------------------------------------------------------------
REM  Compute the number of attendance pts for each employee in employeeRecordsMap!.  The 
REM  "from date" is inside the map as "start_date".  The "to date" is argument "yyyymmddToIn$"
REM  ------------------------------------------------------------------------------------------


compute_and_store_90_day_pts:

    ptsChannel = sqlunt
    sqlopen(ptsChannel) attendPtsDataSource$
    sqlprep(ptsChannel) GET_PTS_TOTAL_RANGE_STMT$
    
    iter! = employeeRecordsMap!.keySet().iterator()
    
    while iter!.hasNext()
    
        badgeKey! = iter!.next()
        employeeDataMap! = cast( java.util.HashMap, employeeRecordsMap!.get(badgeKey!) )
        
        sqlexec(ptsChannel) "0" + badgeKey!, employeeDataMap!.get("start_date"), yyyymmddToIn$
        dim resultRow$:sqltmpl(ptsChannel)
        
        resultRow$ = sqlfetch(ptsChannel,err=*next)
        employeeDataMap!.put("attend_pts", resultRow.pts_total)
        employeeRecordsMap!.put(badgeKey!, employeeDataMap!) 
    
    wend

    sqlclose(ptsChannel)

    return